/*void step_lif_neuron(spiking_nn_t *snn, int t, int neuron_identifier, unsigned char **generated_spikes){
    lif_neuron_t *lif_neuron = &(snn->lif_neurons[neuron_identifier]);
    
    float input_current = 0;

    for(int i=0; i<lif_neuron->input_synapse_amount; i++)
    {
        int next_spike_time = lif_neuron->input_synapses[i]->l_spike_times[lif_neuron->input_synapses[i]->next_spike];
        if(next_spike_time == t){ // check if that must be computed in this timestep
            // Add spike time to neuron received spikes list

            input_current += lif_neuron->input_synapses[i]->w;
            lif_neuron->input_synapses[i]->next_spike = (lif_neuron->input_synapses[i]->next_spike + 1) % lif_neuron->input_synapses[i]->max_spikes; // refresh index
        }
    }

    // compute membrane potential
    lif_neuron->v = lif_neuron->v * (1.0 - DT / TC) + DT / TC * lif_neuron->r * input_current;

    // generate spike if it is necessarylif_neoutput_synapsesuron
    if(lif_neuron->v >= lif_neuron->v_tresh){ // spike
        printf("Spike generated by %d at time %d\n", neuron_identifier+1, t);
        for(int i = 0; i<lif_neuron->output_synapse_amount; i++) {
            lif_neuron->output_synapses[i]->l_spike_times[lif_neuron->output_synapses[i]->last_spike] = t + lif_neuron->output_synapses[i]->delay; // spike
            
            // will reach after delay time
            lif_neuron->output_synapses[i]->last_spike++;

        }
        lif_neuron->v = lif_neuron->v_reset;

        // add spike time to synapses to compute STDP
        for(int i = 0; i<lif_neuron->output_synapse_amount; i++){
            lif_neuron->output_synapses[i]->t_last_pre_spike = t;
        }
        for(int i = 0; i<lif_neuron->input_synapse_amount; i++){
            lif_neuron->input_synapses[i]->t_last_post_spike = t;
        }

        generated_spikes[neuron_identifier][t] = '|';
    }
    else{
        generated_spikes[neuron_identifier][t] = ' ';
    }
}*/

// LIF neuron functions
void initialize_lif_neuron(lif_neuron_t *neuron, int *synapse_matrix, int excitatory_neuron, int length, 
                            int neuron_is_input, int neuron_is_output, int neuron_index){
    // Initialize lif neuron parameters
    neuron->v_tresh = 0.25;
    neuron->v=0.1;
    neuron->r = 0.9;
    neuron->excitatory = excitatory_neuron;

    neuron->n_spikes = 1; // amount of spikes that can be stored (PROVISIONALLY ONE, DEPENDS ON TYPE OF STDP????)

    // neuron is input or output neuron
    neuron->is_input_neuron = neuron_is_input;
    neuron->is_output_neuron = neuron_is_output;

    // Initialize synapses
    int input_synapse_amount = 0, output_synapse_amount = 0;
    
    // count synapses
    for(int i=0; i<length; i++){
        output_synapse_amount += synapse_matrix[neuron_index * length + i]; // row are output synapses
        input_synapse_amount += synapse_matrix[i * length + neuron_index]; // column are input synapses
    }

    // if input neuron at least one input synapse
    if(neuron_is_input==1)
        input_synapse_amount = 1;

    if(neuron_is_output==1)
        output_synapse_amount = 1; // output neurons have one output synapse for now

    // alloc memory to for synapses
    neuron->input_synapse_indexes = malloc(input_synapse_amount * sizeof(int));
    neuron->output_synapse_indexes = malloc(output_synapse_amount * sizeof(int));
    neuron->input_synapse_amount = input_synapse_amount;
    neuron->output_synapse_amount = output_synapse_amount;

    neuron->next_input_synapse = 0; // PROVISIONAL
    neuron->next_output_synapse = 0; // PROVISIONAL
}

void initialize_hh_neuron(){

}


void add_input_synapsis_to_lif_neuron(lif_neuron_t *neuron, int neuron_index){
    neuron->input_synapse_indexes[neuron->actual_input_synapse] = neuron_index;
    neuron->actual_input_synapse++;
}
void add_output_synapsis_to_lif_neuron(lif_neuron_t *neuron, int neuron_index){
    neuron->output_synapse_indexes[neuron->actual_output_synapse] = neuron_index;
    neuron->actual_output_synapse++;
}
/*void add_input_synapsis_to_lif_neuron(lif_neuron_t *neuron, synapse_t *synapse){
    neuron->input_synapses[neuron->actual_input_synapse] = synapse;
    neuron->actual_input_synapse++;
}
void add_output_synapsis_to_lif_neuron(lif_neuron_t *neuron, synapse_t *synapse){
    neuron->output_synapses[neuron->actual_output_synapse] = synapse;
    neuron->actual_output_synapse++;
}*/

/// @brief Initialize synapse data (wegith...)
/// @param synap 
void initialize_synapse_data(synapse_t *synap, float weight, int delay, int max_spikes, int neuron_excitatory){
    //synapse_t synap;
    synap->w = weight;
    if(neuron_excitatory == 0) // if neuron is inhibitory synapse weight is negative 
        synap->w = -weight;

    synap->delay = delay;
    
    // initialize spike list
    synap->l_spike_times = malloc(max_spikes * sizeof(int)); // 10 spikes can be stored
    for (int l = 0; l < max_spikes; l++)
        synap->l_spike_times[l] = -1;
    
    // initialize control indexes
    synap->next_spike = 0;
    synap->last_spike = 0;
    synap->max_spikes = max_spikes;

    // initialize last pre and post synaptic neurons spike times
    synap->t_last_pre_spike = -1; // no spike yet
    synap->t_last_post_spike = -1; // no spike yet
}

// initialize synapses of a neuron (the row)
void initialize_synapses(spiking_nn_t *snn, int pre_index, int post_index, 
                        float weight, int delay, int excitatory, int n_synapse){
    // Initialize all synapses between two neurons 
    //synapse_t synap;
    synapse_t *synap;
    synap = malloc(sizeof(synapse_t));
    initialize_synapse_data(&synap, weight, delay, 100, excitatory);

    printf("Adding synapse between %d and %d neurons\n", pre_index+1, post_index+1);
    if(snn->neuron_type==0){
        add_input_synapsis_to_lif_neuron(&(snn->lif_neurons[post_index]), synap); // synapse is input of the post synaptic neuron
        add_output_synapsis_to_lif_neuron(&(snn->lif_neurons[pre_index]), synap); // synapse is the output of the pre synaptic neuron
    }
    /*else{}*/

    // add synapse to snn synapse list
    snn->synapses[n_synapse] = *synap;
}

// adds NETWORK input synapses
void add_network_input_synapse(spiking_nn_t *snn, int index, float weight, int delay){
    synapse_t *synap;
    synap = malloc(sizeof(synapse_t));
    initialize_synapse_data(&synap, weight, delay, 100, 1);

    if(snn->neuron_type==0)
        add_input_synapsis_to_lif_neuron(&(snn->lif_neurons[index]), synap);
}

void add_network_output_synapse(spiking_nn_t *snn, int index, float weight, int delay){
    synapse_t *synap;
    synap = malloc(sizeof(synapse_t));
    initialize_synapse_data(&synap, weight, delay, 100, 1);
    
    if(snn->neuron_type==0)
        add_output_synapsis_to_lif_neuron(&(snn->lif_neurons[index]), synap);
}

void initialize_network(spiking_nn_t *snn, int n_neurons, int n_input, int n_output, 
                            int *synapses, float *weights, int *delays, 
                            int n_synapses, int *neuron_excitatory){ //void *neuron_initializer()){
    // initialize neurons
    printf("Initializing network with individual neurons\n");

    int input_synapse_amount = 0, output_synapse_amount = 0;

    // check if neuron is an input neuron or output neuron
    printf("Initializing individual neurons...\n");
    for(int i = 0; i<n_neurons; i++)
    {
        // if neuron is input neuron it has only one input synapse
        int neuron_is_input = 0, neuron_is_output = 0;
        if(i<n_input) 
            neuron_is_input = 1;

        // if neuron is output neuron it has only one synapse
        if((n_neurons - i) <= n_output)
            neuron_is_output = 1;

        // initialize neurons
        if(snn->neuron_type==0)
            initialize_lif_neuron(&(snn->lif_neurons[i]), synapses, 
                        neuron_excitatory[i], n_neurons, neuron_is_input, neuron_is_output, i);
        /*
        else {

        }
        */
    }
    printf("Finished neurons initialization\n");

    printf("Initializing network synapses...\n");

    // initialize synapses reading file matrices
    int n_synapse = 0; 
    for(int i = 0; i<snn->n_neurons; i++){
        for(int j=0; j<snn->n_neurons; j++){
            for(int z = 0; z<snn->n_synapses; z++){
                initialize_synapse_data(&(snn->synapses[n_synapse]), weights[i], delays[i], 100, neuron_excitatory[i]);

                // add synapse to neurons: synapse is output for i neuron and input for j
                if(snn->neuron_type == 0){
                    snn->lif_neurons[i].input_synapse_indexes[snn->lif_neurons[j].actual_input_synapse] = n_synapse;
                    snn->lif_neurons[i].actual_input_synapse++;

                    snn->lif_neurons[i].output_synapse_indexes[snn->lif_neurons[j].actual_output_synapse] = n_synapse;
                    snn->lif_neurons[i].actual_output_synapse++;
                }
                n_synapse++;
            }
        }
    }
    /*
    for(int i = 0; i<n_neurons; i++){
        //check if neuron is input or output neuron
        int neuron_is_input = 0, neuron_is_output = 0;
        if(i<n_input) 
            neuron_is_input = 1;

        if((n_neurons - i) <= n_output)
            neuron_is_output = 1;

        for(int j = 0; j<n_neurons; j++)
            for (int z=0; z<synapses[i*n_neurons+j]; z++){
                initialize_synapses(snn, i, j, weights[n_synapse], delays[n_synapse], neuron_excitatory[i], n_synapse);
                n_synapse++;
            }

        if(neuron_is_input)
            add_network_input_synapse(snn,i,10,1);
        if(neuron_is_output)
            add_network_output_synapse(snn,i,10,1);
    }
    */
    printf("Finished synapse initialization\n");
}


void construct_motifs(int *motif_list, int n_motifs){

}


/**
 * Motifs
 */

typedef struct {

} motif_FFE_t;

typedef struct {

} motif_FBE_t;

typedef struct {

} motif_FBI_t;

typedef struct {

} motif_RCE_t;

typedef struct {

} motif_RCI_t;

typedef struct {

} motif_LTI_t;

typedef struct {

} motif_FFI_t;

typedef struct {

} motif_FFRE_t;

typedef struct {

} motif_FFRI_t;

typedef struct {

} motif_FBRE_t;

typedef struct {

} motif_FBRI_t;

typedef struct {

} motif_FFLI_t;

typedef struct {

} motif_FBLI_t;
