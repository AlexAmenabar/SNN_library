# include "nsga2.h"
# include "snn_library.h"

# define KRED "\x1B[31m"
# define KGRN "\x1B[32m"

/* Problem for SNNs: this function adapt the function to avoid the computation of real networks with fixed spike trains */
void test_SNN_test(NSGA2Type *nsga2Params, individual *ind, selected_samples_info_t *selected_samples_info, results_configuration_t *conf){
    // simulate samples 
    int i, j, l, n_samples, n_neurons, n_classes, time_steps, n_repetitions, rep, mode, *sample_indexes, *labels, *n_selected_samples_per_class, **sample_indexes_per_class;
    int **spike_amount_per_neurons_per_sample, *max_distance_per_sample_index;
    double *distance_matrix, *mean_distance_per_sample, *max_distance_per_sample, *inter_class_distance_matrix, *obj1, *obj2;
    int temp_label, temp_mean, temp_global_index, temp_local_index, temp_global_index2, temp_local_index2;
    centroid_info_t *centroid_info;
    int n_inter_class_distances;

    // load info from struct
    mode = nsga2Params->mode;
    n_samples = nsga2Params->n_samples;
    n_repetitions = nsga2Params->n_repetitions;
    n_neurons = ind->snn->n_neurons;
    n_classes = image_dataset.n_classes; // TODO: Generalize this, now is only valid for this dataset
    time_steps = nsga2Params->bins;

    // Initialize struct for storing the results and the configuration of them
    simulation_results_t results;
    //conf->n_samples = n_samples;
    //conf->n_neurons = n_neurons;
    //conf->time_steps = time_steps;

    // call function to allocate memory for results struct
    initialize_results_struct(&results, &conf);

    // arrays to store the amount of spikes generated by each neuron during the simulation of a sample [n_samples x n_neurons]
    spike_amount_per_neurons_per_sample = (int **)malloc(n_samples * sizeof(int *));
    for(i=0; i<n_samples; i++)
        spike_amount_per_neurons_per_sample[i] = (int *)malloc(n_neurons * sizeof(int));

    // distance matrix to store distances between spike trains of samples [n_samples x n_samples]
    distance_matrix = (double *)calloc(n_samples * n_samples, sizeof(double));
    
    // array to store information of clusters: the centroid of each class cluster, the mean distance from the centroid to the rest of samples, and the distance to the sample that is farther
    centroid_info = (centroid_info_t *)calloc(n_classes, sizeof(centroid_info_t));

    // temporal lists to store the mean and max distances to the rest of samples of the class for each sample, and the index of that sample in the list of SELECTED samples (not in the global list of samples) 
    mean_distance_per_sample = (double *)calloc(n_samples, sizeof(double));
    max_distance_per_sample_index = (int *)calloc(n_samples, sizeof(int));
    max_distance_per_sample = (double *)calloc(n_samples, sizeof(double));


    // matrix to store the distances between the classes (distances between the centroids of each class) [n_classes x n_classes]
    inter_class_distance_matrix = (double *)calloc(n_classes * n_classes, sizeof(double));

    // lists to store the values of the objective functions for each repetitions and then compute the mean
    obj1 = (double *)calloc(n_repetitions, sizeof(double));
    obj2 = (double *)calloc(n_repetitions, sizeof(double));    


    // Simulate the networks and compute the objective functions
    for(rep = 0; rep<n_repetitions; rep++){
        // get information about the samples that will be computed in this repetition 
        sample_indexes = selected_samples_info[rep].sample_indexes;
        labels = selected_samples_info[rep].labels;
        n_selected_samples_per_class = selected_samples_info[rep].n_selected_samples_per_class;
        sample_indexes_per_class = selected_samples_info[rep].sample_indexes_per_class;


        // reinitialize lists for this repetition
        for(i=0; i<n_samples; i++){
            mean_distance_per_sample[i] = 0;
            max_distance_per_sample_index[i] = 0;
            max_distance_per_sample[i] = 0;
        }

        printf(" >>>> In repetition %d!\n", rep);

        printf(" >>>>>>>> Print samples labels: ");
        for(i = 0; i<n_samples; i++){
            printf("%d ", image_dataset.labels[sample_indexes[i]]);
        }
        printf("\n");

        printf(" >>>>>>>> Print number of samples per class: ");
        for(i = 0; i<image_dataset.n_classes; i++){
            printf("%d ", n_selected_samples_per_class[i]);
        }
        printf("\n");


        // initialize weights randomly for this repetition
        initialize_synapse_weights(nsga2Params, ind);


        // simulate the network
        simulate_by_samples_enas(ind->snn, nsga2Params, ind, &results, n_samples, sample_indexes, &image_dataset);



        // TODO: First objective: probably should be moved to a function for Modularity

        // TODO: This should be moved to a function
        // sum spikes generated per each neuron and the total amount of spikes per each
        for(i = 0; i<n_samples; i++){
            for(j = 0; j<ind->snn->n_neurons; j++){
                spike_amount_per_neurons_per_sample[i][j] = results.results_per_sample[i].n_spikes_per_neuron[j];
            }
        }

        // TODO: This should be moved to a function 
        // compute the distance matrix for this repetition // TODO: optimize this, the top triangle is enough
        for(i = 0; i<n_samples - 1; i++){
            for(j = i + 1; j<n_samples; j++){
                distance_matrix[i * n_samples + j] = compute_manhattan_distance(spike_amount_per_neurons_per_sample[i], spike_amount_per_neurons_per_sample[j], nsga2Params->bins);
            }
        }
        print_double_matrix(distance_matrix, n_samples);


        // Find centroids and fill neccessary data of "clusters"
        for(i = 0; i<image_dataset.n_classes; i++){
            centroid_info[i].mean_distance = 9999999999999;
            centroid_info[i].farest_point_distance = 0;
        }

        // TODO: This should be moved to a function
        // compute the mean distances to the rest of samples of the class for each class and the max distances [Computaitonal Cost n_samples * (n_samples / n_classes - 1)]
        for(i = 0; i<image_dataset.n_classes; i++){
            for(j=0; j<n_selected_samples_per_class[i]; j++){
                temp_local_index = sample_indexes_per_class[i][j]; // get the index of the sample in the list of samples
                temp_global_index = sample_indexes[temp_local_index]; // get the global index of the sample

                // compute the mean distance with the rest of elements of the class
                for(l=j+1; l<n_selected_samples_per_class[i]; l++){
                    temp_local_index2 = sample_indexes_per_class[i][l]; // get the index of the sample in the list of samples
                    temp_global_index2 = sample_indexes[temp_local_index2]; // get the global index of the sample

                    // sum distances
                    mean_distance_per_sample[temp_local_index] += distance_matrix[temp_local_index * n_samples + temp_local_index2];
                    if(distance_matrix[temp_local_index * n_samples + temp_local_index2] > max_distance_per_sample[temp_local_index]){
                        max_distance_per_sample_index[temp_local_index] = temp_local_index2;
                        max_distance_per_sample[temp_local_index] = distance_matrix[temp_local_index * n_samples + temp_local_index2];
                    }

                    mean_distance_per_sample[temp_local_index2] += distance_matrix[temp_local_index * n_samples + temp_local_index2];
                    if(distance_matrix[temp_local_index * n_samples + temp_local_index2] > max_distance_per_sample[temp_local_index2]){
                        max_distance_per_sample_index[temp_local_index2] = temp_local_index;
                        max_distance_per_sample[temp_local_index2] = distance_matrix[temp_local_index * n_samples + temp_local_index2];
                    }
                }

                // compute the mean for the actual element
                mean_distance_per_sample[temp_local_index] = mean_distance_per_sample[temp_local_index] / n_selected_samples_per_class[i];

                // store the information if the mean distance is smaller
                if(mean_distance_per_sample[temp_local_index] < centroid_info[i].mean_distance){
                    centroid_info[i].mean_distance = mean_distance_per_sample[temp_local_index];
                    centroid_info[i].index = temp_local_index;

                    centroid_info[i].farest_point_index = max_distance_per_sample_index[temp_local_index];
                    centroid_info[i].farest_point_distance = max_distance_per_sample[temp_local_index];

                    printf(" >>>>>> Class %d, mean internal distance %lf, max distance %lf\n", i, centroid_info[i].mean_distance, centroid_info[i].farest_point_distance);
                }   
            }
        }
        printf("\n");
        // compute the distances between the centroids of each class // TODO: I am using a full matrix, but this should be simplified to only the upper triangle
        n_inter_class_distances = 0;
        for(i = 0; i<image_dataset.n_classes-1; i++){
            for(j = i+1; j<image_dataset.n_classes; j++){
                // get distance between class i and class j centroid from distance matrix
                temp_local_index = centroid_info[i].index;
                temp_local_index2 = centroid_info[j].index;

                // get distance between both class centers
                if(temp_local_index < temp_local_index2)
                    inter_class_distance_matrix[i * image_dataset.n_classes + j] = distance_matrix[temp_local_index * n_samples + temp_local_index2];
                else
                    inter_class_distance_matrix[i * image_dataset.n_classes + j] = distance_matrix[temp_local_index2 * n_samples + temp_local_index];

                printf(" >>>>>>> Distance between %d and %d class centroids: %lf\n", i, j, inter_class_distance_matrix[i * image_dataset.n_classes + j]);
                n_inter_class_distances ++;
            }
        }

        // Now we have all the distances we need to compute the objective function

        for(i=0; i<image_dataset.n_classes-1; i++){
            for(j=i+1; j<image_dataset.n_classes; j++){
                obj1[rep] += 
                    (inter_class_distance_matrix[i * image_dataset.n_classes + j] / 
                    (maximum(centroid_info[i].farest_point_distance, centroid_info[j].farest_point_distance) + inter_class_distance_matrix[i * image_dataset.n_classes + j]));
            }
        }
        obj1[rep] /= n_inter_class_distances;
        

        // TODO: Second objective: probably should be moved to a function for Modularity
        for(i = 0; i<n_samples; i++){
            for(j = 0; j<ind->snn->n_neurons; j++){
                obj2[rep] += spike_amount_per_neurons_per_sample[i][j];
            }
        }
        // compute the mean for all samples
        obj2[rep] /= n_samples;
    }


    // compute the mean of the objective functions
    ind->obj[0] = 0;
    ind->obj[1] = 0;

    for(i = 0; i<n_repetitions; i++){
        ind->obj[0]+=obj1[i];
        ind->obj[1]+=obj2[i];
    }

    ind->obj[0] /= n_repetitions;
    ind->obj[1] /= n_repetitions;


    // free all the memory used
    free(obj1);
    free(obj2);
    free(inter_class_distance_matrix);
    free(max_distance_per_sample);
    free(mean_distance_per_sample);
    free(max_distance_per_sample_index);
    free(centroid_info);
    free(distance_matrix);

    for(i=0; i<n_samples; i++)
        free(spike_amount_per_neurons_per_sample[i]);
    free(spike_amount_per_neurons_per_sample);

    free_results_struct_memory(&results, &conf);

    return;
}



// General test, with one doble connection between motifs
int test1(){
    int i, j, equals;
    int *motif_types;
    int_array_t *selected_input_motifs, *new_selected_input_motifs, *new_selected_output_motifs;
    individual *ind;
    int *result_matrix, *target_matrix;
    int n_new_motifs;

    ind = (individual *)malloc(sizeof(individual));
    motif_types = (int *)malloc(3 * sizeof(int));

    // configure test
    ind->n_motifs = 3;
    ind->n_neurons = 0;
    ind->n_synapses = 0;

    motif_types[0] = 0;
    motif_types[1] = 2;
    motif_types[2] = 5;
    //motif_types[3] = 6;

    selected_input_motifs = (int_array_t *)malloc(3 * sizeof(int_array_t));
    selected_input_motifs[0].n = 2;
    selected_input_motifs[1].n = 1;
    selected_input_motifs[2].n = 2;

    selected_input_motifs[0].array = (int *)malloc(2 * sizeof(int));
    selected_input_motifs[1].array = (int *)malloc(1 * sizeof(int));
    selected_input_motifs[2].array = (int *)malloc(2 * sizeof(int));
    
    // select input motifs
    selected_input_motifs[0].array[0] = 1;
    selected_input_motifs[0].array[1] = 1;

    selected_input_motifs[1].array[0] = 2;

    selected_input_motifs[2].array[0] = 0;
    selected_input_motifs[2].array[1] = 1;


    // initialize motifs dynamic list
    //initialize_ind_motifs_from_types(ind, motif_types);
    initialize_ind_test (ind, motif_types, selected_input_motifs, ind->n_motifs);

    // build target matrix
    result_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));
    target_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));

    target_matrix[1] = 1;
    target_matrix[13] = 1;
    target_matrix[15] = 1;

    target_matrix[19] = 1;
    target_matrix[28] = 1;
    target_matrix[32] = 2;
    target_matrix[34] = -1;
    target_matrix[37] = 1;
    target_matrix[39] = 1;
    /*target_matrix[52] = 1;
    target_matrix[53] = 1;
    target_matrix[54] = 1;*/

    target_matrix[42] = 1;
    target_matrix[46] = 1;
    target_matrix[55] = -1;
    target_matrix[58] = 1;

    /*target_matrix[88] = 1;
    target_matrix[93] = 1;
    target_matrix[95] = 1;
    target_matrix[97] = 1;
    target_matrix[98] = 1;
    target_matrix[99] = 1;
    target_matrix[104] = 1;
    target_matrix[106] = 1;
    target_matrix[107] = 1;
    target_matrix[109] = 1;
    target_matrix[110] = 1;
    target_matrix[115] = 1;
    target_matrix[117] = 1;
    target_matrix[118] = 1;
    target_matrix[119] = 1;*/


    // build complete matrix from the obtained sparse matrix
    get_complete_matrix_from_dynamic_list(result_matrix, ind->connectivity_matrix, ind->n_neurons);

    // compare obtained matrix and the expected one
    equals = compare_target_and_obtained_matrix(result_matrix, target_matrix, ind->n_neurons);

# ifdef DEBUG
    print_synapses_dynamic_list(ind->connectivity_matrix);
    print_connectivity_matrix(target_matrix, ind->n_neurons);
    print_connectivity_matrix(result_matrix, ind->n_neurons);
# endif

    n_new_motifs = 1;

    new_selected_input_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));
    new_selected_output_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));

    new_selected_input_motifs[0].n = 1;
    new_selected_output_motifs[0].n = 2;

    new_selected_input_motifs[0].array = (int *)malloc(sizeof(int));
    new_selected_output_motifs[0].array = (int *)malloc(2 * sizeof(int));

    new_selected_input_motifs[0].array[0] = 1;
    new_selected_output_motifs[0].array[0] = 0;
    new_selected_output_motifs[0].array[1] = 2;

    // 14
    //printf("%d\n", ind->n_synapses);

    // now add new motifs and connections and test
    NSGA2Type nsga2Params;
    add_motif_mutation_test(&nsga2Params, ind, n_new_motifs, new_selected_input_motifs, new_selected_output_motifs, 6);

    free(result_matrix);
    free(target_matrix);
    result_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));
    target_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));

    target_matrix[1] = 1;
    target_matrix[16] = 1;
    target_matrix[18] = 1;

    target_matrix[25] = 1;
    target_matrix[37] = 1;
    target_matrix[44] = 2;
    target_matrix[46] = -1;
    target_matrix[49] = 1;
    target_matrix[51] = 1;
    target_matrix[52] = 1;
    target_matrix[53] = 1;
    target_matrix[54] = 1;

    target_matrix[57] = 1;
    target_matrix[61] = 1;
    target_matrix[73] = -1;
    target_matrix[79] = 1;

    target_matrix[88] = 1;
    target_matrix[93] = 1;
    target_matrix[95] = 1;
    target_matrix[97] = 1;
    target_matrix[98] = 1;
    target_matrix[99] = 1;
    target_matrix[104] = 1;
    target_matrix[106] = 1;
    target_matrix[107] = 1;
    target_matrix[109] = 1;
    target_matrix[110] = 1;
    target_matrix[115] = 1;
    target_matrix[117] = 1;
    target_matrix[118] = 1;
    target_matrix[119] = 1;


    // build complete matrix from the obtained sparse matrix
    get_complete_matrix_from_dynamic_list(result_matrix, ind->connectivity_matrix, ind->n_neurons);

    // compare obtained matrix and the expected one
    equals = compare_target_and_obtained_matrix(result_matrix, target_matrix, ind->n_neurons);


# ifdef DEBUG
    print_synapses_dynamic_list(ind->connectivity_matrix);
    print_connectivity_matrix(target_matrix, ind->n_neurons);
    print_connectivity_matrix(result_matrix, ind->n_neurons);
# endif


    new_motif_t *motif_node;
    neuron_node_t *neuron_node;

    // if not equals. return
    if(equals == 1){
        
        // check motifs
        motif_node = ind->motifs_new;
        if(motif_node->motif_type != 0 && motif_node->initial_global_index != 0
            || motif_node->next_motif->motif_type != 2 && motif_node->next_motif->initial_global_index != 2 
            || motif_node->next_motif->next_motif->motif_type != 5 && motif_node->next_motif->next_motif->initial_global_index != 5 
            || motif_node->next_motif->next_motif->next_motif->motif_type != 6 && motif_node->next_motif->next_motif->next_motif->initial_global_index != 8 
            || motif_node->next_motif->next_motif->next_motif->next_motif != NULL){
            equals = 0;
        }

        if(ind->n_motifs != 4 || ind->n_neurons != 11 || ind->n_synapses != 32){
            equals = 0;
        }

        // count neurons too
        int n_neurons = 0;
        neuron_node = ind->neurons;
        while(neuron_node){
            n_neurons ++;
            neuron_node = neuron_node->next_neuron;
        }

        if(ind->n_neurons != n_neurons){
            equals = 0;        
        }
    }
    
    return equals;
}

int test2(){
    int i, j, equals;
    int *motif_types;
    int_array_t *selected_input_motifs, *new_selected_input_motifs, *new_selected_output_motifs;
    individual *ind;
    int *result_matrix, *target_matrix;
    int n_new_motifs;

    ind = (individual *)malloc(sizeof(individual));
    motif_types = (int *)malloc(3 * sizeof(int));

    // set motif types
    motif_types[0] = 0;
    motif_types[1] = 0;
    motif_types[2] = 0;

    selected_input_motifs = (int_array_t *)malloc(2 * sizeof(int_array_t));
    selected_input_motifs[0].n = 6;
    selected_input_motifs[1].n = 6;
    selected_input_motifs[2].n = 6;

    selected_input_motifs[0].array = (int *)malloc(6 * sizeof(int));
    selected_input_motifs[1].array = (int *)malloc(6 * sizeof(int));
    selected_input_motifs[2].array = (int *)malloc(6 * sizeof(int));
    
    // select input motifs
    selected_input_motifs[0].array[0] = 0;
    selected_input_motifs[0].array[1] = 0;
    selected_input_motifs[0].array[2] = 1;
    selected_input_motifs[0].array[3] = 1;
    selected_input_motifs[0].array[4] = 2;
    selected_input_motifs[0].array[5] = 2;

    selected_input_motifs[1].array[0] = 0;
    selected_input_motifs[1].array[1] = 0;
    selected_input_motifs[1].array[2] = 1;
    selected_input_motifs[1].array[3] = 1;
    selected_input_motifs[1].array[4] = 2;
    selected_input_motifs[1].array[5] = 2;

    selected_input_motifs[2].array[0] = 0;
    selected_input_motifs[2].array[1] = 0;
    selected_input_motifs[2].array[2] = 1;
    selected_input_motifs[2].array[3] = 1;
    selected_input_motifs[2].array[4] = 2;
    selected_input_motifs[2].array[5] = 2;


    // initialize motifs dynamic list
    //initialize_ind_motifs_from_types(ind, motif_types);
    ind->n_motifs = 3;
    initialize_ind_test (ind, motif_types, selected_input_motifs, ind->n_motifs);

    // ============= //
    // add new motif //
    // ============= //

    n_new_motifs = 1;

    new_selected_input_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));
    new_selected_output_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));

    new_selected_input_motifs[0].n = 2;
    new_selected_output_motifs[0].n = 3;

    new_selected_input_motifs[0].array = (int *)malloc(2 * sizeof(int));
    new_selected_output_motifs[0].array = (int *)malloc(3 * sizeof(int));

    // set motifs
    new_selected_input_motifs[0].array[0] = 0;
    new_selected_input_motifs[0].array[1] = 3;

    new_selected_output_motifs[0].array[0] = 0;
    new_selected_output_motifs[0].array[1] = 0;
    new_selected_output_motifs[0].array[2] = 1;


    // now add new motifs and connections and test
    NSGA2Type nsga2Params;
    add_motif_mutation_test(&nsga2Params, ind, n_new_motifs, new_selected_input_motifs, new_selected_output_motifs, 0);

    // build target matrix
    result_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));
    target_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));


    target_matrix[1] = 1;
    target_matrix[8] = 2;
    target_matrix[10] = 2;
    target_matrix[12] = 2;
    target_matrix[14] = 1;

    target_matrix[19] = 1;
    target_matrix[24] = 2;
    target_matrix[26] = 2;
    target_matrix[28] = 2;

    target_matrix[37] = 1;
    target_matrix[40] = 2;
    target_matrix[42] = 2;
    target_matrix[44] = 2;

    target_matrix[55] = 1;
    target_matrix[56] = 2;
    target_matrix[58] = 1;
    target_matrix[62] = 1;

    // build complete matrix from the obtained sparse matrix
    get_complete_matrix_from_dynamic_list(result_matrix, ind->connectivity_matrix, ind->n_neurons);

    // compare obtained matrix and the expected one
    equals = compare_target_and_obtained_matrix(result_matrix, target_matrix, ind->n_neurons);


# ifdef DEBUG
    print_synapses_dynamic_list(ind->connectivity_matrix);
    print_connectivity_matrix(target_matrix, ind->n_neurons);
    print_connectivity_matrix(result_matrix, ind->n_neurons);
# endif


    new_motif_t *motif_node;
    neuron_node_t *neuron_node;

    // if not equals. return
    if(equals == 1){
        
        // check motifs
        motif_node = ind->motifs_new;
        if(motif_node->motif_type != 0 && motif_node->initial_global_index != 0
            || motif_node->next_motif->motif_type != 0 && motif_node->next_motif->initial_global_index != 2 
            || motif_node->next_motif->next_motif->motif_type != 0 && motif_node->next_motif->next_motif->initial_global_index != 4 
            || motif_node->next_motif->next_motif->next_motif->motif_type != 0 && motif_node->next_motif->next_motif->next_motif->initial_global_index != 6 
            || motif_node->next_motif->next_motif->next_motif->next_motif != NULL){
            equals = 0;
        }

        if(ind->n_motifs != 4 || ind->n_neurons != 8 || ind->n_synapses != 27){
            equals = 0;
        }

        // count neurons too
        int n_neurons = 0;
        neuron_node = ind->neurons;
        while(neuron_node){
            n_neurons ++;
            neuron_node = neuron_node->next_neuron;
        }

        if(ind->n_neurons != n_neurons){
            equals = 0;        
        }
    }
    
    return equals;
}

int test3(){
    int i, j, equals;
    int *motif_types;
    int_array_t *selected_input_motifs, *new_selected_input_motifs, *new_selected_output_motifs;
    individual *ind;
    int *result_matrix, *target_matrix;
    int n_new_motifs;

    ind = (individual *)malloc(sizeof(individual));
    motif_types = (int *)malloc(2 * sizeof(int));

    // set motif types
    motif_types[0] = 0;
    motif_types[1] = 0;

    selected_input_motifs = (int_array_t *)malloc(2 * sizeof(int_array_t));
    selected_input_motifs[0].n = 4;
    selected_input_motifs[1].n = 4;

    selected_input_motifs[0].array = (int *)malloc(4 * sizeof(int));
    selected_input_motifs[1].array = (int *)malloc(4 * sizeof(int));
    
    // select input motifs
    selected_input_motifs[0].array[0] = 0;
    selected_input_motifs[0].array[1] = 0;
    selected_input_motifs[0].array[2] = 1;
    selected_input_motifs[0].array[3] = 1;

    selected_input_motifs[1].array[0] = 0;
    selected_input_motifs[1].array[1] = 0;
    selected_input_motifs[1].array[2] = 1;
    selected_input_motifs[1].array[3] = 1;


    // initialize motifs dynamic list
    //initialize_ind_motifs_from_types(ind, motif_types);
    ind->n_motifs = 2;
    initialize_ind_test (ind, motif_types, selected_input_motifs, ind->n_motifs);

    // ============= //
    // add new motif //
    // ============= //

    n_new_motifs = 2;

    new_selected_input_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));
    new_selected_output_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));

    new_selected_input_motifs[0].n = 6;
    new_selected_output_motifs[0].n = 4;

    new_selected_input_motifs[1].n = 2;
    new_selected_output_motifs[1].n = 3;

    new_selected_input_motifs[0].array = (int *)malloc(6 * sizeof(int));
    new_selected_output_motifs[0].array = (int *)malloc(4 * sizeof(int));

    new_selected_input_motifs[1].array = (int *)malloc(2 * sizeof(int));
    new_selected_output_motifs[1].array = (int *)malloc(3 * sizeof(int));

    // set motifs
    new_selected_input_motifs[0].array[0] = 0;
    new_selected_input_motifs[0].array[1] = 0;
    new_selected_input_motifs[0].array[2] = 1;
    new_selected_input_motifs[0].array[3] = 1;
    new_selected_input_motifs[0].array[4] = 2;
    new_selected_input_motifs[0].array[5] = 2;

    new_selected_output_motifs[0].array[0] = 0;
    new_selected_output_motifs[0].array[1] = 0;
    new_selected_output_motifs[0].array[2] = 1;
    new_selected_output_motifs[0].array[3] = 1;


    new_selected_input_motifs[1].array[0] = 0;
    new_selected_input_motifs[1].array[1] = 3;

    new_selected_output_motifs[1].array[0] = 0;
    new_selected_output_motifs[1].array[1] = 0;
    new_selected_output_motifs[1].array[2] = 1;


    // now add new motifs and connections and test
    NSGA2Type nsga2Params;
    add_motif_mutation_test(&nsga2Params, ind, n_new_motifs, new_selected_input_motifs, new_selected_output_motifs, 0);

    // build target matrix
    result_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));
    target_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));


    target_matrix[1] = 1;
    target_matrix[8] = 2;
    target_matrix[10] = 2;
    target_matrix[12] = 2;
    target_matrix[14] = 1;

    target_matrix[19] = 1;
    target_matrix[24] = 2;
    target_matrix[26] = 2;
    target_matrix[28] = 2;

    target_matrix[37] = 1;
    target_matrix[40] = 2;
    target_matrix[42] = 2;
    target_matrix[44] = 2;

    target_matrix[55] = 1;
    target_matrix[56] = 2;
    target_matrix[58] = 1;
    target_matrix[62] = 1;

    // build complete matrix from the obtained sparse matrix
    get_complete_matrix_from_dynamic_list(result_matrix, ind->connectivity_matrix, ind->n_neurons);

    // compare obtained matrix and the expected one
    equals = compare_target_and_obtained_matrix(result_matrix, target_matrix, ind->n_neurons);


# ifdef DEBUG
    print_synapses_dynamic_list(ind->connectivity_matrix);
    print_connectivity_matrix(target_matrix, ind->n_neurons);
    print_connectivity_matrix(result_matrix, ind->n_neurons);
# endif


    new_motif_t *motif_node;
    neuron_node_t *neuron_node;

    // if not equals. return
    if(equals == 1){
        
        // check motifs
        motif_node = ind->motifs_new;
        if(motif_node->motif_type != 0 && motif_node->initial_global_index != 0
            || motif_node->next_motif->motif_type != 0 && motif_node->next_motif->initial_global_index != 2 
            || motif_node->next_motif->next_motif->motif_type != 0 && motif_node->next_motif->next_motif->initial_global_index != 4 
            || motif_node->next_motif->next_motif->next_motif->motif_type != 0 && motif_node->next_motif->next_motif->next_motif->initial_global_index != 6 
            || motif_node->next_motif->next_motif->next_motif->next_motif != NULL){
            equals = 0;
        }

        if(ind->n_motifs != 4 || ind->n_neurons != 8 || ind->n_synapses != 27){
            equals = 0;
        }

        // count neurons too
        int n_neurons = 0;
        neuron_node = ind->neurons;
        while(neuron_node){
            n_neurons ++;
            neuron_node = neuron_node->next_neuron;
        }

        if(ind->n_neurons != n_neurons){
            equals = 0;        
        }
    }
    
    return equals;
}

int test4(){
    int i, j, equals;
    int *motif_types;
    int_array_t *selected_input_motifs, *new_selected_input_motifs, *new_selected_output_motifs;
    individual *ind;
    int *result_matrix, *target_matrix;
    int n_new_motifs;

    ind = (individual *)malloc(sizeof(individual));
    motif_types = (int *)malloc(2 * sizeof(int));

    // set motif types
    motif_types[0] = 0;
    motif_types[1] = 0;

    selected_input_motifs = (int_array_t *)malloc(2 * sizeof(int_array_t));
    selected_input_motifs[0].n = 4;
    selected_input_motifs[1].n = 4;

    selected_input_motifs[0].array = (int *)malloc(4 * sizeof(int));
    selected_input_motifs[1].array = (int *)malloc(4 * sizeof(int));
    
    // select input motifs
    selected_input_motifs[0].array[0] = 0;
    selected_input_motifs[0].array[1] = 0;
    selected_input_motifs[0].array[2] = 1;
    selected_input_motifs[0].array[3] = 1;

    selected_input_motifs[1].array[0] = 0;
    selected_input_motifs[1].array[1] = 0;
    selected_input_motifs[1].array[2] = 1;
    selected_input_motifs[1].array[3] = 1;


    // initialize motifs dynamic list
    //initialize_ind_motifs_from_types(ind, motif_types);
    ind->n_motifs = 2;
    initialize_ind_test (ind, motif_types, selected_input_motifs, ind->n_motifs);

    // ============= //
    // add new motif //
    // ============= //

    n_new_motifs = 2;

    new_selected_input_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));
    new_selected_output_motifs = (int_array_t *)malloc(n_new_motifs * sizeof(int_array_t));

    new_selected_input_motifs[0].n = 7;
    new_selected_output_motifs[0].n = 7;

    new_selected_input_motifs[1].n = 3;
    new_selected_output_motifs[1].n = 1;

    new_selected_input_motifs[0].array = (int *)malloc(7 * sizeof(int));
    new_selected_output_motifs[0].array = (int *)malloc(7 * sizeof(int));

    new_selected_input_motifs[1].array = (int *)malloc(3 * sizeof(int));
    new_selected_output_motifs[1].array = (int *)malloc(1 * sizeof(int));

    // set motifs
    new_selected_input_motifs[0].array[0] = 0;
    new_selected_input_motifs[0].array[1] = 0;
    new_selected_input_motifs[0].array[2] = 1;
    new_selected_input_motifs[0].array[3] = 1;
    new_selected_input_motifs[0].array[4] = 2;
    new_selected_input_motifs[0].array[5] = 2;
    new_selected_input_motifs[0].array[6] = 3;

    new_selected_output_motifs[0].array[0] = 0;
    new_selected_output_motifs[0].array[1] = 0;
    new_selected_output_motifs[0].array[2] = 1;
    new_selected_output_motifs[0].array[3] = 1;
    new_selected_output_motifs[0].array[4] = 3;
    new_selected_output_motifs[0].array[5] = 3;
    new_selected_output_motifs[0].array[6] = 3;


    new_selected_input_motifs[1].array[0] = 0;
    new_selected_input_motifs[1].array[1] = 2;
    new_selected_input_motifs[1].array[2] = 3;

    new_selected_output_motifs[1].array[0] = 2;


    // now add new motifs and connections and test
    NSGA2Type nsga2Params;
    add_motif_mutation_test(&nsga2Params, ind, n_new_motifs, new_selected_input_motifs, new_selected_output_motifs, 0);

    // build target matrix
    result_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));
    target_matrix = (int *)calloc(ind->n_neurons * ind->n_neurons, sizeof(int));


    target_matrix[1] = 1;
    target_matrix[8] = 2;
    target_matrix[10] = 2;
    target_matrix[12] = 2;
    target_matrix[14] = 1;

    target_matrix[19] = 1;
    target_matrix[24] = 2;
    target_matrix[26] = 2;
    target_matrix[28] = 2;

    target_matrix[37] = 1;
    target_matrix[40] = 2;
    target_matrix[42] = 2;
    target_matrix[44] = 2;
    target_matrix[46] = 4;

    target_matrix[55] = 1;
    target_matrix[60] = 2;
    target_matrix[62] = 1;

    // build complete matrix from the obtained sparse matrix
    get_complete_matrix_from_dynamic_list(result_matrix, ind->connectivity_matrix, ind->n_neurons);

    // compare obtained matrix and the expected one
    equals = compare_target_and_obtained_matrix(result_matrix, target_matrix, ind->n_neurons);


# ifdef DEBUG
    print_synapses_dynamic_list(ind->connectivity_matrix);
    print_connectivity_matrix(target_matrix, ind->n_neurons);
    print_connectivity_matrix(result_matrix, ind->n_neurons);
# endif


    new_motif_t *motif_node;
    neuron_node_t *neuron_node;

    // if not equals. return
    if(equals == 1){
        
        // check motifs
        motif_node = ind->motifs_new;
        if(motif_node->motif_type != 0 && motif_node->initial_global_index != 0
            || motif_node->next_motif->motif_type != 0 && motif_node->next_motif->initial_global_index != 2 
            || motif_node->next_motif->next_motif->motif_type != 0 && motif_node->next_motif->next_motif->initial_global_index != 4 
            || motif_node->next_motif->next_motif->next_motif->motif_type != 0 && motif_node->next_motif->next_motif->next_motif->initial_global_index != 6 
            || motif_node->next_motif->next_motif->next_motif->next_motif != NULL){
            equals = 0;
        }

        if(ind->n_motifs != 4 || ind->n_neurons != 8 || ind->n_synapses != 30){
            equals = 0;
        }

        // count neurons too
        int n_neurons = 0;
        neuron_node = ind->neurons;
        while(neuron_node){
            n_neurons ++;
            neuron_node = neuron_node->next_neuron;
        }

        if(ind->n_neurons != n_neurons){
            equals = 0;        
        }
    }
    
    return equals;
}


void print_result(int result, int test_id){
    if(result == 1) printf("      Tests %d: SUCCESS!!\n", test_id, KGRN);
    else printf("      Tests %d: FAILURE!!\n", test_id, KRED);
}

void print_results(int *results, int n){
    int i;
    for( i=0; i<n; i++){
        if(results[i] == 1) printf("      Tests %d: SUCCESS!!\n", i, KGRN);
        else printf("      Tests %d: FAILURE!!\n", i, KRED);
    }
}

int main(int argc, char **argv){
    int results[4];
    
    initialize_motifs();

    printf("   = == ====== == ====== == =   \nStarting tests: add motif mutation\n   = == ====== == ====== == =   \n");

    results[0] = test1();
    print_result(results[0], 0);
    
    results[1] = test2();
    print_result(results[1], 1);

    results[2] = test3();
    print_result(results[2], 2);
    
    results[3] = test4();
    print_result(results[3], 3);

    printf("\n");
}