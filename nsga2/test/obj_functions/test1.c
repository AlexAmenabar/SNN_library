/* Routine for evaluating population members  */

# include <stdio.h>
# include <stdlib.h>
# include <math.h>
# include <time.h>

# include "nsga2.h"
# include "rand.h"

# include "snn_library.h"
# include "load_data.h"
# include "helpers.h"
# include "training_rules/stdp.h"
# include "neuron_models/lif_neuron.h"
# include "snnfuncs.h"
# include "distance_comp.h"

#include "../test.h"


void test1(){
    // simulate samples 
    int temp_label, temp_mean, temp_global_index, temp_local_index, temp_global_index2, temp_local_index2;
    double **acc_per_class, *acc, *final_acc_per_class, final_acc;
    int i, j, l, n_samples, n_neurons, n_classes, time_steps, n_repetitions, rep, mode, n_obj, total, success;
    int *sample_indexes, *labels, *n_selected_samples_per_class, **sample_indexes_per_class;

    // this is received as parameters in the original functions
    NSGA2Type *nsga2Params; 
    individual *ind;
    selected_samples_info_t *selected_samples_info;

    nsga2Params = (NSGA2Type *)calloc(1, sizeof(NSGA2Type));
    nsga2Params->n_classes = 2;
    nsga2Params->n_samples = 6;
    nsga2Params->n_repetitions = 2;
    nsga2Params->bins = 5;
    nsga2Params->obj_functions_info = (obj_functions_t *)calloc(1, sizeof(obj_functions_t));

    ind = (individual *)calloc(1, sizeof(individual));
    ind->n_neurons = 3;

    // load info from struct
    n_samples = nsga2Params->n_samples;
    n_repetitions = nsga2Params->n_repetitions;
    n_neurons = ind->n_neurons;
    n_classes = nsga2Params->n_classes; // TODO: Generalize this, now is only valid for this dataset
    time_steps = nsga2Params->bins;

    obj_functions_t *ctx = nsga2Params->obj_functions_info;
    selected_samples_info = (selected_samples_info_t *)calloc(1, sizeof(selected_samples_info_t));
    selected_samples_info->sample_indexes = (int *)malloc(n_samples * sizeof(int));
    selected_samples_info->labels = (int *)calloc(n_samples, sizeof(int));
    selected_samples_info->n_selected_samples_per_class = (int *)calloc(n_classes, sizeof(int));
    selected_samples_info->sample_indexes_per_class = (int **)calloc(n_classes, sizeof(int *));
    for(i = 0; i<n_classes; i++)
        selected_samples_info->sample_indexes_per_class[i] = (int *)calloc(3, sizeof(int));

    selected_samples_info->sample_indexes[0] = 0;
    selected_samples_info->sample_indexes[1] = 1;
    selected_samples_info->sample_indexes[2] = 2;
    selected_samples_info->sample_indexes[3] = 3;
    selected_samples_info->sample_indexes[4] = 4;
    selected_samples_info->sample_indexes[5] = 5;

    selected_samples_info->labels[0] = 0;
    selected_samples_info->labels[1] = 0;
    selected_samples_info->labels[2] = 0;
    selected_samples_info->labels[3] = 1;
    selected_samples_info->labels[4] = 1;
    selected_samples_info->labels[5] = 1;

    selected_samples_info->n_selected_samples_per_class[0] = 3;
    selected_samples_info->n_selected_samples_per_class[1] = 3;

    selected_samples_info->sample_indexes_per_class[0][0] = 0;
    selected_samples_info->sample_indexes_per_class[0][1] = 1;
    selected_samples_info->sample_indexes_per_class[0][2] = 2;
    selected_samples_info->sample_indexes_per_class[1][0] = 3;
    selected_samples_info->sample_indexes_per_class[1][1] = 4;
    selected_samples_info->sample_indexes_per_class[1][2] = 5;
    

    ctx->selected_samples_info = selected_samples_info;

    
    // TODO: this function should be more general for allowing the use of different objective functions

    // =================================== //
    // Allocate memory for neccessary data //
    // =================================== //

    // arrays to store the amount of spikes generated by each neuron during the simulation of a set of samples [n_samples x n_neurons]
    ctx->spike_amount_per_neurons_per_sample = (int **)calloc(n_samples, sizeof(int *));
    for(i=0; i<n_samples; i++)
        ctx->spike_amount_per_neurons_per_sample[i] = (int *)calloc(n_neurons, sizeof(int));

    // distance matrix to store distances between spike trains generated for different samples [n_repetitions x n_samples x n_samples]
    ctx->distance_matrix = (double *)calloc(n_samples * n_samples, sizeof(double));
    
    // lists to store the values of the objective functions of different repetitions // This could be done only once
    ctx->obj_values = (double *)calloc(n_obj * n_repetitions, sizeof(double));

    // array to store information of clusters: the centroid of each class cluster, the mean distance from the centroid to the rest of samples, and the distance to the sample that is farther
    ctx->centroid_info = (centroid_info_t *)calloc(n_classes, sizeof(centroid_info_t));

    // temporal lists to store the mean and max distances to the rest of samples of the class for each sample, and the index of that sample in the list of SELECTED samples (not in the global list of samples) 
    ctx->mean_distance_per_sample = (double *)calloc(n_samples, sizeof(double));
    ctx->max_distance_per_sample_index = (int *)calloc(n_samples, sizeof(int));
    ctx->max_distance_per_sample = (double *)calloc(n_samples, sizeof(double));

    // matrix to store the distances between the classes (distances between the centroids of each class) [n_classes x n_classes]
    ctx->inter_class_distance_matrix = (double *)calloc(n_classes * n_classes, sizeof(double));

    // allocate memory for list to store accuracies
    acc = (double *)calloc(n_repetitions, sizeof(double));
    acc_per_class = (double **)calloc(n_classes, sizeof(double *));
    for(i = 0; i<n_classes; i++)
        acc_per_class[i] = (double *)calloc(n_repetitions, sizeof(double));

    final_acc_per_class = (double *)calloc(n_classes, sizeof(double));
    final_acc = 0;


    // ========================================================= //
    // Simulate the networks and compute the objective functions //
    // ========================================================= //
    n_obj = 2;
    for(rep = 0; rep<n_repetitions; rep++){

        printf(" In repetition %d\n", rep);
        fflush(stdout);

        ctx->rep = rep;
        ctx->rep = 0;

        // get information about the samples that will be computed in this repetition 
        sample_indexes = selected_samples_info->sample_indexes; // store the indexes of the selected samples
        labels = selected_samples_info->labels; // store the labels of the selected samples
        n_selected_samples_per_class = selected_samples_info->n_selected_samples_per_class; // store the number of samples selected per each class
        sample_indexes_per_class = selected_samples_info->sample_indexes_per_class; // store the indexes of the samples for each class*/


        // =========================== //
        // Compute objective functions //
        // =========================== //

        // TODO: First objective: probably should be moved to a function for Modularity
        ctx->spike_amount_per_neurons_per_sample[0][0] = 3;
        ctx->spike_amount_per_neurons_per_sample[0][1] = 1;
        ctx->spike_amount_per_neurons_per_sample[0][2] = 1;
        ctx->spike_amount_per_neurons_per_sample[1][0] = 3;
        ctx->spike_amount_per_neurons_per_sample[1][1] = 2;
        ctx->spike_amount_per_neurons_per_sample[1][2] = 1;
        ctx->spike_amount_per_neurons_per_sample[2][0] = 3;
        ctx->spike_amount_per_neurons_per_sample[2][1] = 2;
        ctx->spike_amount_per_neurons_per_sample[2][2] = 3;
        ctx->spike_amount_per_neurons_per_sample[3][0] = 1;
        ctx->spike_amount_per_neurons_per_sample[3][1] = 3;
        ctx->spike_amount_per_neurons_per_sample[3][2] = 3;
        ctx->spike_amount_per_neurons_per_sample[4][0] = 2;
        ctx->spike_amount_per_neurons_per_sample[4][1] = 2;
        ctx->spike_amount_per_neurons_per_sample[4][2] = 2;
        ctx->spike_amount_per_neurons_per_sample[5][0] = 3;
        ctx->spike_amount_per_neurons_per_sample[5][1] = 1;
        ctx->spike_amount_per_neurons_per_sample[5][2] = 3;

        // compute the distance matrix if it is required for computing some of the objective functions
        compute_distance_matrix(ctx->distance_matrix, n_samples, ctx->spike_amount_per_neurons_per_sample, n_neurons);
        printf(" Distance matrix computed\n");
        fflush(stdout);

        compute_distance_info(nsga2Params, ind, ctx);
        printf(" Class distance info computed\n");
        fflush(stdout);

        ctx->rep = rep;
        ctx->obj_values[rep * n_obj + 0] = my_metric(nsga2Params, ind, ctx);
        printf(" Objective function 1 computed\n");
        fflush(stdout);
        ctx->obj_values[rep * n_obj + 1] = count_spikes_per_neuron(nsga2Params, ind, ctx);
        printf(" Objective function 2 computed\n");
        fflush(stdout);


        // compute accuracy
        success = 0;
        int c_success = 0;
        int founded = 0;
        double tmp_distance = 0;
        
        for(i = 0; i<n_classes; i++){ // compute for each class;

            c_success = 0;

            for(j=0; j<n_selected_samples_per_class[i]; j++){ // loop over all samples selected for this class

                temp_local_index = sample_indexes_per_class[i][j]; // get the index of the sample in the list of samples (local index)
                temp_local_index2 = ctx->centroid_info[i].index; // get the local index of the centroid


                // get the distance of the sample with the centroid of its class
                tmp_distance = 0;

                if(temp_local_index < temp_local_index2)
                    tmp_distance = ctx->distance_matrix[temp_local_index * n_samples + temp_local_index2];
                else if(temp_local_index > temp_local_index2)
                    tmp_distance = ctx->distance_matrix[temp_local_index2 * n_samples + temp_local_index];
                else
                    tmp_distance = 0;

                // loop over all classes and check if the distance with its class is the minimum
                l = 0;
                founded = 0;
                while(l<n_classes && founded == 0){
                    
                    if(temp_local_index < ctx->centroid_info[l].index){
                        if(ctx->distance_matrix[temp_local_index * n_samples + ctx->centroid_info[l].index] < tmp_distance)
                            founded = 1;
                    }
                    else if(temp_local_index > ctx->centroid_info[l].index){
                        if(ctx->distance_matrix[ctx->centroid_info[l].index * n_samples + temp_local_index] < tmp_distance)
                            founded = 1;
                    }

                    l++;
                }
                
                if(founded == 0){
                    success ++;
                    c_success ++;
                }
            }

            acc_per_class[i][rep] = (double)c_success / (double)n_selected_samples_per_class[i]; 
        }

        acc[rep] = (double)success / (double)n_samples;
    }


    // =========================================== //
    // compute the mean of the objective functions //
    // =========================================== //

    ind->obj = (double *)calloc(2, sizeof(double));
    n_obj = 2;

    for(i = 0; i<n_obj; i++){
        ind->obj[i] = 0;
        for(j = 0; j<n_repetitions; j++)
            ind->obj[i] += ctx->obj_values[n_obj * j + i];
        
        // compute the mean for all repetitions
        ind->obj[i] = ind->obj[i] / n_repetitions;

        printf(" Objective function %d: %f\n", i, ind->obj[i]);
    }


    // compute accuracy means
    final_acc = 0;
    for(i = 0; i<n_repetitions; i++){
        final_acc += acc[i];
        for(j = 0; j<n_classes; j++)
            final_acc_per_class[j] += acc_per_class[j][i];
    } 
    final_acc = (double)final_acc / (double)n_repetitions;
    for(i = 0; i<n_classes; i++)
        final_acc_per_class[i] = (double)final_acc_per_class[i] / (double)n_repetitions;


    // ======================== //
    // free all the memory used //
    // ======================== //

    free(ctx->obj_values);
    free(ctx->inter_class_distance_matrix);
    free(ctx->max_distance_per_sample);
    free(ctx->mean_distance_per_sample);
    free(ctx->max_distance_per_sample_index);
    free(ctx->centroid_info);
    free(ctx->distance_matrix);
    
    for(i=0; i<n_samples; i++)
        free(ctx->spike_amount_per_neurons_per_sample[i]);
    free(ctx->spike_amount_per_neurons_per_sample);


    // REVISE ALL RELATED TO
    free(acc);
    for(i = 0; i<n_classes; i++)
        free(acc_per_class[i]);
    free(acc_per_class);
    free(final_acc_per_class);

    return;
}


int main(int argc, char **argv){
    int results[4];
    
    initialize_motifs();

    printf("   = == ====== == ====== == =   \nStarting tests: objective functions computation\n   = == ====== == ====== == =   \n");

    test1();
    
    
    printf("\n");
}