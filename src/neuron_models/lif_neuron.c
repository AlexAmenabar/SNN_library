#include "snn_library.h"
#include "neuron_models/lif_neuron.h"

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>


void lif_neuron_compute_input_synapses(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    lif_neuron_t *lif_neuron = &(snn->lif_neurons[neuron_id]);
    int i, next_spike_time; // next spike to process;
    float input_current = 0;
    int synapse_index;
    synapse_t *synapse;

//        printf(" - Processing neuron %d \n", neuron_id);


    #ifdef DEBUG
    //if(t==61)
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    // if neuron on reset state don't process
    if(lif_neuron->r_time_rest > 0){
        lif_neuron->r_time_rest --;
        
        // no spike generated
        results->generated_spikes[neuron_id][t] = ' ';
    }
    else{ // if r_t equal to 0 start processing neuron again
        // check all input synapses to find if there are spikes to process
        for(i=0; i<lif_neuron->n_input_synapse; i++)
        {
            //printf("neuron %d processing synapse %d\n", neuron_id, i);
            synapse_index = lif_neuron->input_synapse_indexes[i]; // get synapse
            synapse = &(snn->synapses[synapse_index]);

            #ifdef DEBUG
                printf(" -- Processing input synapse %d: ", synapse_index);
            #endif

            next_spike_time = synapse->l_spike_times[synapse->next_spike];
            // neuron was on refractory state, so ignore all not processed spikes

            int atascau = 0; 
            while (next_spike_time < t && synapse->next_spike != synapse->last_spike){ //refesh index util is the same as actual spike or list is finished  // && next_spike_time != -1){
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
                next_spike_time = synapse->l_spike_times[synapse->next_spike];
                
                //if(t == 61)
                //    printf("Time step: %d, next_spike = %d, last_spike = %d, next_spike_time = %d, neuron index: %d, synapse index: %d\n", t, synapse->next_spike, synapse->last_spike, next_spike_time, neuron_id, synapse_index);
                atascau ++;
                if(atascau >= 1000){ 
                    //printf("Atascau, neuron = %d, synapse = %d, t = %d, next_spike_time = %d, next_spike = %d, last_spike = %d, max_spikes = %d\n", neuron_id, synapse_index, t, next_spike_time, synapse->next_spike, synapse->last_spike, synapse->max_spikes);
                }
            }

            // if next spike time is equals to actual time step, process
            if(next_spike_time == t){
                #ifdef DEBUG
                    printf(" SPIKE");
                #endif
                
                // add spike time to neuron received spikes list
                input_current += synapse->w;

                // refresh next spike index
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
            }

            #ifdef DEBUG
                printf("\n");
            #endif
        }

        float temp_v = lif_neuron->v;
        // compute membrane potential
        lif_neuron->v =  lif_neuron->v * (1 - 1 / 20) + input_current;  //(0.2) * (-(lif_neuron->v - lif_neuron->v_rest) + lif_neuron->r * input_current); // (1 / 5)
    }
}

void lif_neuron_compute_output_synapses(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    lif_neuron_t *lif_neuron = &(snn->lif_neurons[neuron_id]);
    int i, next_spike_time; // next spike to process;
    float input_current = 0;
    int synapse_index;
    synapse_t *synapse;

//        printf(" - Processing neuron %d \n", neuron_id);


    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    // if neuron on reset state don't process
    if(lif_neuron->r_time_rest == 0){
        // if r_t equal to 0 start processing neuron again
        // generate spike if it is necessary
        //printf("Neuron %d generated spike on time %d\n", neuron_id, t);
        if(lif_neuron->v >= lif_neuron->v_tresh){
            #ifdef DEBUG
                printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
            #endif

            // send spike to all output synapses
            for(i = 0; i<lif_neuron->n_output_synapse; i++){
                synapse_index = lif_neuron->output_synapse_indexes[i]; // get synapse index
                synapse = &(snn->synapses[synapse_index]);

                #ifdef DEBUG
                    printf(" --- Processing output synapse %d: spike located for time %d\n", synapse_index, t + synapse->delay);
                #endif

                // add spike to output synapse
                synapse->l_spike_times[synapse->last_spike] = t + synapse->delay;

                // refresh last spike index
                synapse->last_spike = (synapse->last_spike + 1) % synapse->max_spikes;//synapse->max_spikes;

                //printf(" max_spikes = %d, last spike = %d\n", synapse->max_spikes, synapse_last_spike);
                //if(synapse->max_spikes == 20 && synapse->last_spike == 20)
                    //printf("Raro raro\n");
                // register spike time on output synapses
                //synapse->t_last_pre_spike = t; // neuron is pre synaptic neuron for output synapses
            }
            lif_neuron->t_last_spike = t; // last spike generated by the neuron
            lif_neuron->r_time_rest = lif_neuron->r_time; // refractory time
            lif_neuron->v = lif_neuron->v_reset; // reset potential

            // for output
            results->generated_spikes[neuron_id][t] = '|';
            results->n_spikes_per_neuron[neuron_id] += 1;

            //*spike_amount += 1;
        }
        else{
            // no spike generated
            results->generated_spikes[neuron_id][t] = ' ';
        }
    } 
}

void lif_neuron_step(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    lif_neuron_t *lif_neuron = &(snn->lif_neurons[neuron_id]);
    int i, next_spike_time; // next spike to process;
    float input_current = 0;
    int synapse_index;
    synapse_t *synapse;


    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    // if neuron on reset state don't process
    if(lif_neuron->r_time_rest > 0){
        lif_neuron->r_time_rest --;
        
        // no spike generated
        results->generated_spikes[neuron_id][t] = ' ';
    }
    else{ // if r_t equal to 0 start processing neuron again
        // check all input synapses to find if there are spikes to process
        for(i=0; i<lif_neuron->n_input_synapse; i++)
        {
            //printf("neuron %d processing synapse %d\n", neuron_id, i);
            synapse_index = lif_neuron->input_synapse_indexes[i]; // get synapse
            synapse = &(snn->synapses[synapse_index]);

            #ifdef DEBUG
                printf(" -- Processing input synapse %d: ", synapse_index);
            #endif

            next_spike_time = synapse->l_spike_times[synapse->next_spike];
            // neuron was on refractory state, so ignore all not processed spikes

            int atascau = 0; 
            while (next_spike_time < t && synapse->next_spike != synapse->last_spike){ //refesh index util is the same as actual spike or list is finished  // && next_spike_time != -1){
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
                next_spike_time = synapse->l_spike_times[synapse->next_spike];
                
                //if(t == 61)
                //    printf("Time step: %d, next_spike = %d, last_spike = %d, next_spike_time = %d, neuron index: %d, synapse index: %d\n", t, synapse->next_spike, synapse->last_spike, next_spike_time, neuron_id, synapse_index);
                atascau ++;
                if(atascau >= 1000){ 
                    //printf("Atascau, neuron = %d, synapse = %d, t = %d, next_spike_time = %d, next_spike = %d, last_spike = %d, max_spikes = %d\n", neuron_id, synapse_index, t, next_spike_time, synapse->next_spike, synapse->last_spike, synapse->max_spikes);
                }
            }

            // if next spike time is equals to actual time step, process
            if(next_spike_time == t){
                #ifdef DEBUG
                    printf(" SPIKE");
                #endif
                
                // add spike time to neuron received spikes list
                input_current += synapse->w;

                // refresh next spike index
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
            }

            #ifdef DEBUG
                printf("\n");
            #endif
        }

        float temp_v = lif_neuron->v;
        // compute membrane potential
        lif_neuron->v =  lif_neuron->v * (1 - 1 / 20) + input_current;  //(0.2) * (-(lif_neuron->v - lif_neuron->v_rest) + lif_neuron->r * input_current); // (1 / 5)
    
    
        // compute output step
                // if r_t equal to 0 start processing neuron again
        // generate spike if it is necessary
        //printf("Neuron %d generated spike on time %d\n", neuron_id, t);
        if(lif_neuron->v >= lif_neuron->v_tresh){
            #ifdef DEBUG
                printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
            #endif

            // send spike to all output synapses
            for(i = 0; i<lif_neuron->n_output_synapse; i++){
                synapse_index = lif_neuron->output_synapse_indexes[i]; // get synapse index
                synapse = &(snn->synapses[synapse_index]);

                #ifdef DEBUG
                    printf(" --- Processing output synapse %d: spike located for time %d\n", synapse_index, t + synapse->delay);
                #endif

                // add spike to output synapse
                synapse->l_spike_times[synapse->last_spike] = t + synapse->delay;

                // refresh last spike index
                synapse->last_spike = (synapse->last_spike + 1) % synapse->max_spikes;//synapse->max_spikes;

                if(synapse->max_spikes == 20 && synapse->last_spike == 20)
                    printf("Raro raro\n");
                // register spike time on output synapses
                //synapse->t_last_pre_spike = t; // neuron is pre synaptic neuron for output synapses
            }
            lif_neuron->t_last_spike = t; // last spike generated by the neuron
            lif_neuron->r_time_rest = lif_neuron->r_time; // refractory time
            lif_neuron->v = lif_neuron->v_reset; // reset potential

            // for output
            results->generated_spikes[neuron_id][t] = '|';
            results->n_spikes_per_neuron[neuron_id] += 1;

            //*spike_amount += 1;
        }
        else{
            // no spike generated
            results->generated_spikes[neuron_id][t] = ' ';
        }
    }
}

// Same as step_lif neuron but it computes STDP in function. MUST BE REVISED BEFORE USING IT; TODO
// same as last but in this case STDP is computed inside function
void step_lif_neuron_stdp_integrated(spiking_nn_t *snn, int t, int neuron_id, unsigned char **generated_spikes){
    lif_neuron_t *lif_neuron = &(snn->lif_neurons[neuron_id]);
    int i;
    float input_current = 0;

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    // check all input synapses to find if there are spikes to process
    for(i=0; i<lif_neuron->n_input_synapse; i++)
    {
        int synapse_index = lif_neuron->input_synapse_indexes[i]; // get synapse
        synapse_t *synapse = &(snn->synapses[synapse_index]);

        #ifdef DEBUG
            printf(" -- Processing input synapse %d: ", synapse_index);
        #endif

        int next_spike_time; // next spike to process
        next_spike_time = synapse->l_spike_times[synapse->next_spike];

        // if next spike time is equals to actual time step, process
        if(next_spike_time == t){
            #ifdef DEBUG
                printf(" SPIKE");
            #endif
            
            // add spike time to neuron received spikes list
            input_current += synapse->w;

            // refresh next spike index
            synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
        }

        #ifdef DEBUG
            printf("\n");
        #endif
    }

    float temp_v = lif_neuron->v;
    // compute membrane potential
    lif_neuron->v +=  (1.0 / 5) * (-(lif_neuron->v - lif_neuron->v_rest) + lif_neuron->r * input_current);

    #ifdef DEBUG
        printf(" -- Processing membrane potential: \n --- Initial v: %f \n --- Input current: %f \n --- Actual v: %f \n --- calculation: %f\n", temp_v, input_current, lif_neuron->v, (1.0 / 5) * (-(lif_neuron->v - lif_neuron->v_rest) + lif_neuron->r * input_current));
    #endif

    #ifdef DEBUG
        printf(" -- Checking if spike must be generated: v = %f, v_tresh = %f\n", lif_neuron->v, lif_neuron->v_tresh);
    #endif

    // generate spike if it is necessary
    if(lif_neuron->v >= lif_neuron->v_tresh){
        #ifdef DEBUG
            printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
        #endif

        // send spike to all output synapses
        for(i = 0; i<lif_neuron->n_output_synapse; i++){
            int synapse_index = lif_neuron->output_synapse_indexes[i]; // get synapse index
            synapse_t *synapse = &(snn->synapses[synapse_index]);

            #ifdef DEBUG
                printf(" --- Processing output synapse %d: spike located for time %d\n", synapse_index, t + synapse->delay);
            #endif

            // add spike to output synapse
            synapse->l_spike_times[synapse->last_spike] = t + synapse->delay;

            // refresh last spike index
            synapse->last_spike = (synapse->last_spike + 1) % synapse->max_spikes;

            // register spike time on output synapses
            synapse->t_last_pre_spike = t; // neuron is pre synaptic neuron for output synapses

            // indicate that the neuron has been processed (this is pre neuron for output synapses)
            /*synapse->pre_neuron_computed = 1;

            // compute STDP if both neurons connected to this synapse have been processed
            if(synapse->post_neuron_computed == 1 && synapse->pre_neuron_computed == 1){
                synapse->post_neuron_computed = 0;
                synapse->pre_neuron_computed = 0;

                // compute STDP
                synapse->learning_rule(synapse); // rarete
            }*/
        }
        #ifdef DEBUG
            printf("Output synapses computed\n");
        #endif

        // register spike time on input synapses (NOT COMPATIBLE WITH GPU IMPLEMENTATION???)
        for(i=0; i<lif_neuron->n_input_synapse; i++){
            int synapse_index = lif_neuron->input_synapse_indexes[i]; // get synapse index
            synapse_t *synapse = &(snn->synapses[synapse_index]);

            synapse->t_last_post_spike = t; // this neuron is postsynaptic neuron for input synapses

            // indicate that this neuron has been processed to synapse
            //synapse->post_neuron_computed = 1;

            // compute STDP if both neurons connected to this synapse have been processed (STDP is computed after all information of synapse on time t has been computed)
            /*if(synapse->post_neuron_computed == 1 && synapse->pre_neuron_computed == 1){
                synapse->post_neuron_computed = 0;
                synapse->pre_neuron_computed = 0;

                // compute STDP
                synapse->learning_rule(synapse); // rarete
            }*/
        }
        #ifdef DEBUG
            printf("Input synapses computed\n");
        #endif

        lif_neuron->v = lif_neuron->v_reset;


        // for output
        generated_spikes[neuron_id][t] = '|';
    }
    else{
    /*    
        #ifdef DEBUG 
            printf("Number of output synapses: %d; Number of input synapses: %d\n", lif_neuron->n_output_synapse, lif_neuron->n_input_synapse);
        #endif

        // indicate that this neuron has been processed to all output synapses
        for(i = 0; i<lif_neuron->n_output_synapse; i++){
            // get synapse
            int synapse_index = lif_neuron->output_synapse_indexes[i]; // get synapse index
            synapse_t *synapse = &(snn->synapses[synapse_index]); // get synapse

            // indicate that the neuron has been processed (this is pre neuron for output synapses)
            synapse->pre_neuron_computed = 1;

            // compute STDP if both neurons connected to this synapse have been processed
            if(synapse->post_neuron_computed == 1 && synapse->pre_neuron_computed == 1){
                synapse->post_neuron_computed = 0;
                synapse->pre_neuron_computed = 0;

                // compute STDP
                synapse->learning_rule(synapse); // rarete
            }
        }

        #ifdef DEBUG
            printf("Output synapses computed\n");
        #endif

        // register spike time on input synapses (NOT COMPATIBLE WITH GPU IMPLEMENTATION???)
        for(i=0; i<lif_neuron->n_input_synapse; i++){
            int synapse_index = lif_neuron->input_synapse_indexes[i]; // get synapse index
            synapse_t *synapse = &(snn->synapses[synapse_index]);

            // indicate that this neuron has been processed to synapse
            synapse->post_neuron_computed = 1;

            // compute STDP if both neurons connected to this synapse have been processed (STDP is computed after all information of synapse on time t has been computed)
            /*if(synapse->post_neuron_computed == 1 && synapse->pre_neuron_computed == 1){
                synapse->post_neuron_computed = 0;
                synapse->pre_neuron_computed = 0;

                // compute STDP
                synapse->learning_rule(synapse); // rarete
            }*/
        /*}

        #ifdef DEBUG
            printf("Input synapses computed\n");
        #endif*/

        // no spike generated
        generated_spikes[neuron_id][t] = ' ';
    }

    #ifdef DEBUG
        printf("\n");
    #endif
}


//void initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, int excitatory, int **synaptic_connections, int n_input_synapse, int n_output_synapse){
void initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, network_construction_lists_t *lists, int n_input_synapse, int n_output_synapse){
 
    // Initialize lif neuron parameters
    int i;

    // load neuron and its information from lists
    lif_neuron_t *neuron = &(snn->lif_neurons[neuron_index]);
    neuron->v_tresh = lists->v_thres_list[neuron_index];//1;//150;//-50;//0.25;
    neuron->v_rest = 0;//-65;// -70 to -50 mV --> random value on that range?
    neuron->v_reset = 0;//-70;
    neuron->v= neuron->v_rest; //0.1;
    neuron->r = 10;
    neuron->excitatory = lists->neuron_excitatory[neuron_index];//excitatory;
    neuron->r_time_rest = 0;
    neuron->r_time = lists->r_time_list[neuron_index];//2;

    // check if neuron is input/output neuron 
    if(neuron_index < snn->n_input)
        neuron->is_input_neuron = 1;
    else
        neuron->is_input_neuron = 0;

    if(neuron_index >= (snn->n_neurons - snn->n_output))
        neuron->is_output_neuron = 1;
    else
        neuron->is_output_neuron = 0;


    // TEMPORAL SOLUTION; TODO BETTER IMPLEMENTATION. This should be 0 only for input synpases,
    // but I don't want to add an IF in the executed function as that will make the execution less
    // efficient
    if(neuron->is_input_neuron == 1 || neuron->is_output_neuron == 1)
        neuron->r_time = 0;
    
    // reserve memory to store synapses indexes
    neuron->input_synapse_indexes = malloc(n_input_synapse * sizeof(int));
    neuron->output_synapse_indexes = malloc(n_output_synapse * sizeof(int));
    
    // store number of input and output synpases for neuron
    neuron->n_input_synapse = n_input_synapse;
    neuron->n_output_synapse = n_output_synapse;

    // initialize control variables MUST BE REVISED THE USE OF THESE
    neuron->next_input_synapse = 0; 
    neuron->next_output_synapse = 0;

    neuron->t_last_spike = -1;
}

void re_initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, network_construction_lists_t *lists){
    // Initialize lif neuron parameters
    lif_neuron_t *neuron = &(snn->lif_neurons[neuron_index]);
    neuron->v_tresh = lists->v_thres_list[neuron_index];//1;//150;//-50;//0.25;
    neuron->v_rest = 0;//-65;// -70 to -50 mV --> random value on that range?
    neuron->v_reset = 0;//-70;
    neuron->v= neuron->v_rest; //0.1;
    neuron->r = 10;
    neuron->excitatory = lists->neuron_excitatory[neuron_index];//excitatory;
    neuron->r_time_rest = 0;
    neuron->r_time = lists->r_time_list[neuron_index];//2;

    // reinitialize control parameters
    neuron->next_input_synapse = 0; 
    neuron->next_output_synapse = 0;

    neuron->t_last_spike = -1;
}

void add_input_synapse_to_lif_neuron(lif_neuron_t *neuron, synapse_t* synapse, int synapse_index){
    neuron->input_synapse_indexes[neuron->next_input_synapse] = synapse_index;
    neuron->next_input_synapse += 1;

    // add neuron to synapse
    //synapse->post_synaptic_lif_neuron = malloc(sizeof(lif_neuron_t));
    synapse->post_synaptic_lif_neuron = neuron;
}


void add_output_synapse_to_lif_neuron(lif_neuron_t *neuron, synapse_t *synapse, int synapse_index){
    neuron->output_synapse_indexes[neuron->next_output_synapse] = synapse_index;
    neuron->next_output_synapse += 1;

    //synapse->pre_synaptic_lif_neuron = malloc(sizeof(lif_neuron_t));
    synapse->pre_synaptic_lif_neuron = neuron;
}
