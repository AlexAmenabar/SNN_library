#include "../include/snn_library.h"
#include "../include/load_data.h"
#include "helpers.c"
#include "../include/training_rules/stdp.h"

#define REFRAC_TIME
#define T 100 // tiempo total de la simulaciÃ³n (ms)
#define DT 1.0 // paso del tiempo (ms)
#define TC 0.9 // time constant parameter

/** LIF NEURON FUNCTIONS */

void step_lif_neuron(spiking_nn_t *snn, int t, int neuron_id, unsigned char **generated_spikes){
    lif_neuron_t *lif_neuron = &(snn->lif_neurons[neuron_id]);
    int i;
    float input_current = 0;

#ifdef DEBUG
    printf(" - Processing neuron %d \n", neuron_id);
#endif

    // check all input synapses to find if there are spikes to process
    for(i=0; i<lif_neuron->n_input_synapse; i++)
    {
        int synapse_index = lif_neuron->input_synapse_indexes[i]; // get synapse
        synapse_t *synapse = &(snn->synapses[synapse_index]);

#ifdef DEBUG
        printf(" -- Processing input synapse %d: ", synapse_index);
#endif

        int next_spike_time; // next spike to process
        next_spike_time = synapse->l_spike_times[synapse->next_spike];

        // if next spike time is equals to actual time step, process
        if(next_spike_time == t){
#ifdef DEBUG
            printf(" SPIKE");
#endif
            // add spike time to neuron received spikes list
            input_current += synapse->w;

            // refresh next spike index
            synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
        }

        // indicate that this neuron has been processed to synapse
        synapse->post_neuron_computed = 1;

        // compute STDP if both neurons connected to this synapse have been processed
        if(synapse->post_neuron_computed == 1 && synapse->pre_neuron_computed == 1){
            synapse->post_neuron_computed = 0;
            synapse->pre_neuron_computed = 0;

            // compute STDP
            synapse->learning_rule(synapse); // rarete
        }

#ifdef DEBUG
        printf("\n");
#endif
    }

    float temp_v = lif_neuron->v;
    // compute membrane potential
    //lif_neuron->v = lif_neuron->v * (1.0 - DT / TC) + DT / TC * lif_neuron->r * input_current;
    lif_neuron->v = lif_neuron->v + (DT / TC) * (-(lif_neuron->v - lif_neuron->v_rest)) + lif_neuron->r * input_current;

#ifdef DEBUG
    printf(" -- Processing membrane potential: \n --- Initial v: %f \n --- Input current: %f \n --- Actual v: %f \n --- calculation: %f\n", temp_v, input_current, lif_neuron->v, (DT / TC) * (-(lif_neuron->v - lif_neuron->v_rest)));
#endif

#ifdef DEBUG
    printf(" -- Checking if spike must be generated: v = %f, v_tresh = %f\n", lif_neuron->v, lif_neuron->v_tresh);
#endif

    // generate spike if it is necessary
    if(lif_neuron->v >= lif_neuron->v_tresh){
#ifdef DEBUG
        printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
 #endif

        // send spike to all output synapses
        for(i = 0; i<lif_neuron->n_output_synapse; i++){
            int synapse_index = lif_neuron->output_synapse_indexes[i]; // get synapse index
            synapse_t *synapse = &(snn->synapses[synapse_index]);

#ifdef DEBUG
            printf(" --- Processing output synapse %d: spike located for time %d\n", synapse_index, t + synapse->delay);
#endif

            // add spike to output synapse
            synapse->l_spike_times[synapse->last_spike] = t + synapse->delay;

            // refresh last spike index
            synapse->last_spike = (synapse->last_spike + 1) % synapse->max_spikes;

            // register spike time on output synapses
            synapse->t_last_pre_spike = t; // neuron is pre synaptic neuron for output synapses

            // indicate that the neuron has been processed (this is pre neuron for output synapses)
            synapse->pre_neuron_computed = 1;

            // compute STDP if both neurons connected to this synapse have been processed
            if(synapse->post_neuron_computed == 1 && synapse->pre_neuron_computed == 1){
                synapse->post_neuron_computed = 0;
                synapse->pre_neuron_computed = 0;

                // compute STDP
                synapse->learning_rule(synapse); // rarete
            }
        }

        // register spike time on input synapses (NOT COMPATIBLE WITH GPU IMPLEMENTATION???)
        for(i=0; i<lif_neuron->n_input_synapse; i++){
            int synapse_index = lif_neuron->input_synapse_indexes[i]; // get synapse index
            synapse_t *synapse = &(snn->synapses[synapse_index]);

            synapse->t_last_post_spike = t; // this neuron is postsynaptic neuron for input synapses
        }

        lif_neuron->v = lif_neuron->v_reset;


        // for output
        generated_spikes[neuron_id][t] = '|';
    }
    else{
        // indicate that this neuron has been processed to all output synapses
        for(i = 0; i<snn->n_output_synapses; i++){
            // get synapse
            int synapse_index = lif_neuron->output_synapse_indexes[i]; // get synapse index
            synapse_t *synapse = &(snn->synapses[synapse_index]); // get synapse

            // indicate that the neuron has been processed (this is pre neuron for output synapses)
            synapse->pre_neuron_computed = 1;

            // compute STDP if both neurons connected to this synapse have been processed
            if(synapse->post_neuron_computed == 1 && synapse->pre_neuron_computed == 1){
                synapse->post_neuron_computed = 0;
                synapse->pre_neuron_computed = 0;

                // compute STDP
                synapse->learning_rule(synapse); // rarete
            }
        }

        // no spike generated
        generated_spikes[neuron_id][t] = ' ';
    }



#ifdef DEBUG
    printf("\n");
#endif
}


void initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, int excitatory, int *synapse_matrix){
    // Initialize lif neuron parameters
    int i;

    lif_neuron_t *neuron = &(snn->lif_neurons[neuron_index]);
    neuron->v_tresh = -50;//0.25;
    neuron->v_rest = -65;// -70 to -50 mV --> random value on that range?
    neuron->v_reset = -65;
    neuron->v= neuron->v_rest; //0.1;
    neuron->r = 10;
    neuron->excitatory = excitatory;

    // check if neuron is input/output neuron 
    if(neuron_index < snn->n_input)
        neuron->is_input_neuron = 1;
    else
        neuron->is_input_neuron = 0;

    if((snn->n_neurons - snn->n_output) <= neuron_index)
        neuron->is_output_neuron = 1;
    else
        neuron->is_output_neuron = 0;

    // Initialize synapse data
    int n_input_synapse = 0, n_output_synapse = 0;
    
    // count input synapses
    for(i=0; i<snn->n_neurons; i++)
        n_input_synapse += synapse_matrix[i * (snn->n_neurons+1) + neuron_index]; // input synapses are found on the column
   
    // count output synapses
    for(i=1; i<snn->n_neurons+1;i++)
        n_output_synapse += synapse_matrix[(neuron_index + 1) * (snn->n_neurons + 1) + i]; // input synapses are found on the row

    // reserve memory to store synapses indexes
    neuron->input_synapse_indexes = malloc(n_input_synapse * sizeof(int));
    neuron->output_synapse_indexes = malloc(n_output_synapse * sizeof(int));
    neuron->n_input_synapse = n_input_synapse;
    neuron->n_output_synapse = n_output_synapse;

    neuron->next_input_synapse = 0; 
    neuron->next_output_synapse = 0;
}

void initialize_network_neurons(spiking_nn_t *snn, int *neuron_behaviour_list, int *synapse_matrix){
    int i;

    if(snn->neuron_type == 0){ // lif neurons
        snn->lif_neurons = (lif_neuron_t *)malloc(snn->n_neurons * sizeof(lif_neuron_t)); // reserve memory for lif neurons
    }
    // else {}

    for(i=0; i<snn->n_neurons; i++)
        if(snn->neuron_type == 0) // lif neuron
            initialize_lif_neuron(snn, i, neuron_behaviour_list[i], synapse_matrix);
}

/** SYNAPSE FUNCTIONS */

void initialize_synapse(synapse_t *synapse, float w, int delay, int training){
    synapse->w = w;
    synapse->delay = delay;
    synapse->max_spikes = MAX_SPIKES;

    synapse->t_last_post_spike = -1;
    synapse->t_last_pre_spike = -1;
    
    synapse->post_neuron_computed = -1;
    synapse->pre_neuron_computed = -1;
    
    synapse->last_spike = 0; 
    synapse->next_spike = 0;

    synapse->l_spike_times = (int *)malloc(MAX_SPIKES * sizeof(int));
    for(int i = 0; i<MAX_SPIKES; i++)
        synapse->l_spike_times[i] = -1; // no spikes yet

    // set training rule
    switch (training)
    {
    case 0:
        synapse->learning_rule = &add_stdp;
        break;
    case 1:
        synapse->learning_rule = &mult_stdp;
        break;
    case 2:
        synapse->learning_rule = &anti_stdp;
        break;
    case 3:
        synapse->learning_rule = &triplet_stdp;
        break;
    default:
        break;
    }
    if(training == 0){

    }
    
}

void initialize_network_synapses(spiking_nn_t *snn, int n_synapses, float *weight_list, int *delay_list, int *training_zones){
    // reserve memory for synapses
    snn->synapses = (synapse_t *)malloc(n_synapses * sizeof(synapse_t));

    for(int i = 0; i<n_synapses; i++)
        initialize_synapse(&(snn->synapses[i]), weight_list[i], delay_list[i], training_zones[i]);
}


void add_input_synapse_to_lif_neuron(lif_neuron_t *neuron, int synapse_index){
    neuron->input_synapse_indexes[neuron->next_input_synapse] = synapse_index;
    neuron->next_input_synapse += 1;
}

void add_input_synapse_to_neuron(spiking_nn_t *snn, int neuron_index, int synapse_index){
    if(snn->neuron_type == 0)
        add_input_synapse_to_lif_neuron(&snn->lif_neurons[neuron_index], synapse_index);
    // else{}
}

void add_output_synapse_to_lif_neuron(lif_neuron_t *neuron, int synapse_index){
    neuron->output_synapse_indexes[neuron->next_output_synapse] = synapse_index;
    neuron->next_output_synapse += 1;
}

void add_output_synapse_to_neuron(spiking_nn_t *snn, int neuron_index, int synapse_index){
    if(snn->neuron_type == 0)
        add_output_synapse_to_lif_neuron(&snn->lif_neurons[neuron_index], synapse_index);
    // else{}
}

void connect_neurons_and_synapses(spiking_nn_t *snn, int *synapse_matrix){
    int n_neurons = snn->n_neurons;
    int n_input = snn->n_input;
    int n_output = snn->n_output;

    int i, j, l;
    int i_synapse = 0; // index of the actual synapse

    // connect neurons with input synapses
    for(i = 0; i<n_neurons; i++){
        for(j = 0; j<n_neurons; j++){
            for(l = 0; l<synapse_matrix[i * (n_neurons+1) + j]; l++) {
                add_input_synapse_to_neuron(snn, j, i_synapse);
                i_synapse++;
            }
        }
    }

    // connect output synapses to neurons
    i_synapse = 0;
    for(i = 0; i<n_neurons+1; i++){
        for(j=0; j<n_neurons+1; j++){
            for(l = 0; l<synapse_matrix[i * (n_neurons+1) + j]; l++) {
                if(i!=0) // first row is only for input synapses
                    add_output_synapse_to_neuron(snn, i-1, i_synapse); // i-1 as neuron goes from 0 to n_neurons-1, last column is for synapses
                i_synapse++;
            }
        }
    }
}


void initialize_network(spiking_nn_t *snn, int neuron_type, int n_neurons, int n_input, int n_output, int n_synapses, int n_input_synapses, int n_output_synapses, 
                    int *neuron_behaviour_list, int *synapse_matrix, float *weight_list, int *delay_list, int *training_zones){ //void *neuron_initializer()){
#ifdef DEBUF
    printf("Initializing network...\n");
#endif

    // initialize general information
    snn->n_neurons = n_neurons;
    snn->n_input = n_input;
    snn->n_output = n_output;
    snn->n_synapses = n_synapses;
    snn->neuron_type = neuron_type;

    snn->n_input_synapses = n_input_synapses; 
    snn->n_output_synapses = n_output_synapses;

    // initialize neurons of the network
    initialize_network_neurons(snn, neuron_behaviour_list, synapse_matrix);

    // initialize synapses
    initialize_network_synapses(snn, n_synapses, weight_list, delay_list, training_zones);

    // connect neurons and synapses
    connect_neurons_and_synapses(snn, synapse_matrix);

#ifdef DEBUF
    printf("Network correctly initialized!\n");
#endif
}



/* main.c */
int main(int argc, char *argv[]) {
    // variables definition
    int execution_type, neuron_type, n_neurons, n_input, n_output, n_synapses, n_input_synapses, n_output_synapses;
    int *motif_list;
    int simulation_type, time_steps, time_step=0;

    int *synapse_matrix, *delay_list, *neuron_excitatory, *training_zones;
    float *weight_list;

    void *neuron_initializer; // function to initialize neurons
    void (*step)(); // functions to run a step on the simulation

    int i;

    // Load information from input parameters
    execution_type = strtoul(argv[1], NULL, 10);
    neuron_type = strtoul(argv[2], NULL, 10);
    simulation_type = strtoul(argv[3], NULL, 10);


    // load information about the snn from file
    load_network_information(argv[4], &n_neurons, &n_input, &n_output, &n_synapses, &n_input_synapses, &n_output_synapses,
                            &synapse_matrix, &neuron_excitatory, &weight_list, &delay_list, &training_zones);


    time_steps = strtoul(argv[5], NULL, 10);

#ifdef DEBUG
    // print general information about the simulation / training
    printf("===================\n");
    printf("Execution properies:\n");
    printf(" - Execution type = %d\n", execution_type);
    printf(" - Neuron type for exectution = %d\n", neuron_type);
    printf(" - Simulation / training / testing = %d\n", simulation_type);
    printf(" - Number neurons = %d\n", n_neurons);
    printf(" - Number input neurons = %d\n", n_input);
    printf(" - Number output neurons = %d\n", n_output);
    printf(" - Number synapses = %d\n", n_synapses);
    printf(" - Number input synapses = %d\n", n_input_synapses);
    printf(" - Number output synapses = %d\n", n_output_synapses);
    printf(" - Neurons behaviour: ");
    print_array(neuron_excitatory, n_synapses);
    printf(" - Synapse matrix:\n");
    print_matrix(n_neurons, n_neurons, synapse_matrix);
    printf(" - Weights list: ");
    print_array_f(weight_list, n_synapses);
    printf(" - Delays list: ");
    print_array(delay_list, n_synapses);
    printf(" - Training zones: ");
    print_array(training_zones, n_synapses);
    printf("===================\n\n");

#endif


    // initialize snn structure
    spiking_nn_t snn;
    initialize_network(&snn, neuron_type, n_neurons, n_input, n_output, n_synapses, n_input_synapses, n_output_synapses, 
                        neuron_excitatory, synapse_matrix, weight_list, delay_list, training_zones);


#ifdef DEBUG
    // print information of network neurons
    printf("Printing neuron information...\n");
    for(i = 0; i<snn.n_neurons; i++){
        if(snn.neuron_type == 0){
            printf("Neuron %d: \n - V = %f\n - Excitatory = %d\n - Is input = %d\n - Is output = %d\n - n input synapses = %d\n - n output synapses = %d\n", 
                    i, snn.lif_neurons[i].v, snn.lif_neurons[i].excitatory, snn.lif_neurons[i].is_input_neuron, snn.lif_neurons[i].is_output_neuron, 
                    snn.lif_neurons[i].n_input_synapse, snn.lif_neurons[i].n_output_synapse);
        }
    }
    printf("===================\n\n");
#endif

#ifdef DEBUG
    // print information of network synapses
    printf("Printing synapses information...\n");
    for(i = 0; i<snn.n_synapses; i++)
        printf("Synapse %d: \n - W = %f\n - Delay = %d\n", 
                i, snn.synapses[i].w, snn.synapses[i].delay);
    printf("===================\n\n");
#endif

#ifdef DEBUG
    // print information of network synapses
    printf("Printing neuron input synapses...\n");
    for(i = 0; i<snn.n_neurons; i++){
        printf("Neuron %d inpyt synapse indexes (%d): ", i, snn.lif_neurons[i].n_input_synapse);
        for(int j = 0; j<snn.lif_neurons[i].n_input_synapse; j++){
            printf("%d ", snn.lif_neurons[i].input_synapse_indexes[j]);
        }
        printf("\n");
    }
       
    printf("===================\n\n");

    printf("Printing neuron output synapses...\n");
    for(i = 0; i<snn.n_neurons; i++){
        printf("Neuron %d output synapse indexes (%d): ", i, snn.lif_neurons[i].n_output_synapse);
        for(int j = 0; j<snn.lif_neurons[i].n_output_synapse; j++){
            printf("%d ", snn.lif_neurons[i].output_synapse_indexes[j]);
        }
        printf("\n");
    }
       
    printf("===================\n\n");
#endif

    load_input_spike_trains_on_snn(argv[6], &snn);

    // variable to store generated spikes
    unsigned char **generated_spikes = malloc(n_neurons * sizeof(unsigned char *));
    for (int i = 0; i<n_neurons; i++)
        generated_spikes[i] = malloc(time_steps * sizeof(unsigned char));


    /*for(int i = 0; i<n_input_synapses; i++){
        int t_controller = 0;
        for(int j = 0; j<snn.synapses[i].l_spike_times[snn.synapses[i].last_spike]; j++){
            if(snn.synapses[i].l_spike_times[t_controller] == j)
                generated_spikes[i][j] = '|'; 
            else
                generated_spikes[i][j] = ' '; 
        }
    }*/

#ifdef DEBUG

    printf("Printing network input synapses input spike times: \n", i);

    // print spike trains
    for(i = 0; i<snn.n_input; i++){
        printf("Printing synapse %d input spike times: ", i);
        if(snn.neuron_type == 0){ // lif neurons
            int synapse_index = snn.lif_neurons[i].input_synapse_indexes[0]; // now there is only one input synapse on network input neurons
            for(int j = 0; j<=snn.synapses[synapse_index].last_spike; j++){
                printf("%d ", snn.synapses[synapse_index].l_spike_times[j]);
            }
        }
        // else{}
        printf("\n");
    }
#endif


    // Initialize step function depending on neuron type
    switch (neuron_type)
    {
        case 0: // LIF
            step = &step_lif_neuron;
            break;
        case 1: // HH
            break;
        default:
            break;
    }

#ifdef DEBUG
    printf("Initializing training / simulation\n");
#endif

    // simulation / training
    if(execution_type == 0){ // clock
        while(time_step < time_steps){
#ifdef DEBUG
            printf("Processing time step %d\n", time_step);
#endif
            // process all neurons
            #pragma omp parallel for
            for(int i=0; i<snn.n_neurons; i++){
                step(&snn, time_step, i, generated_spikes);
            }             
            time_step++;

            printf(" - Printing synapses weights: \n");
            for(i = 0; i<snn.n_synapses; i++){
                printf(" -- Synapse %d: %f\n", i, snn.synapses[i].w);
            }
            printf("\n=======================================\n\n");
        }
    }
    //else{}

    // print spikes generated by each neuron
    FILE *output_file;
    output_file = fopen("output_spikes.txt", "w");
    if(output_file == NULL){
        printf("Error opening the file. \n");
        exit(1);
    }
    printf("File openned\n");
    for (int i = 0; i<n_neurons; i++)
    {
        for(int j = 0; j<time_steps; j++){
            fprintf(output_file, "%c", generated_spikes[i][j]);
        }
        fprintf(output_file, "\n");
    }
    
    // free memory
    free(snn.lif_neurons);
    free(snn.synapses);

    return 0;
}