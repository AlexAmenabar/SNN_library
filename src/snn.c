#include "../include/snn_library.h"
#include "load_data.c"
#include "helpers.c"

#define REFRAC_TIME
#define T 100 // tiempo total de la simulaciÃ³n (ms)
#define DT 1.0 // paso del tiempo (ms)
#define TC 0.9 // time constant parameter

void compute_STDP(){

}

// LIF neuron functions
void initialize_lif_neuron(lif_neuron_t *neuron, int n_input_synapse, int n_output_synapse, int excitatory){
    neuron->v_tresh = 0.25;
    neuron->v=0.1;
    neuron->r = 0.9;
    neuron->excitatory = excitatory;

    // alloc memory to for synapses
    neuron->input_synapses = malloc(n_input_synapse * sizeof(synapse_t));
    neuron->output_synapses = malloc(n_output_synapse * sizeof(synapse_t));
    neuron->input_synapse_amount = n_input_synapse;
    neuron->output_synapse_amount = n_output_synapse;

}

void step_lif_neuron(){

}

void forward_pass(lif_neuron_t *lif_neuron, int t, int neuron_identifier, unsigned char **generated_spikes){
    float input_current = 0;

    // compute input current
    //int *i_processed_synapses = malloc(lif_neuron->input_synapse_amount * sizeof(int));
    //int i_proc_synap_amount = 0;

    for(int i=0; i<lif_neuron->input_synapse_amount; i++)
    {
        int next_spike_time = lif_neuron->input_synapses[i].l_spike_times[lif_neuron->input_synapses[i].next_spike];
        if(next_spike_time == t){ // check if that must be computed in this timestep
            input_current += lif_neuron->input_synapses[i].w;
            lif_neuron->input_synapses[i].next_spike = (lif_neuron->input_synapses[i].next_spike + 1) % lif_neuron->input_synapses[i].max_spikes; // refresh index

            // store to process STDP later
            //i_processed_synapses[i_proc_synap_amount] = i;
            //i_proc_synap_amount ++;

            // process STDP
        }
    }

    // compute membrane potential
    lif_neuron->v = lif_neuron->v * (1.0 - DT / TC) + DT / TC * lif_neuron->r * input_current;

    // generate spike if it is necessarylif_neoutput_synapsesuron
    if(lif_neuron->v >= lif_neuron->v_tresh){ // spike
        printf("Spike generated by %d at time %d\n", neuron_identifier+1, t);
        for(int i = 0; i<lif_neuron->output_synapse_amount; i++) {
            lif_neuron->output_synapses[i].l_spike_times[lif_neuron->output_synapses[i].last_spike] = t + lif_neuron->output_synapses[i].delay; // spike
            
            // will reach after delay time
            lif_neuron->output_synapses[i].last_spike++;

        }

        lif_neuron->v = lif_neuron->v_reset;
        generated_spikes[neuron_identifier][t] = '|';

        //STDP using
        /*for(int i = 0; i<i_proc_synap_amount; i++){
            continue;
            //lif_neuron->input_synapses[i_processed_synapses[i]].l_spike_times[next_spike-1]; // MIRAR ESTO, SI NEXT_SPIKE == 0 PROBLEMAS
            // process STDP
        } */
    }
    else{
        generated_spikes[neuron_identifier][t] = ' ';
    }
}

// STDP
void STDP(int t_a, int t_b){

}


void initialize_lif_neuron(lif_neuron_t *neuron, int *synapse_matrix, int length, int neuron_is_input, int neuron_is_output, int neuron_index){
    neuron->v_tresh = 0.25;
    neuron->v=0.1;
    neuron->r = 0.9;
    int input_synapse_amount = 0, output_synapse_amount = 0;
    
    // count synapses
    for(int i=0; i<length; i++){
        output_synapse_amount += synapse_matrix[neuron_index * length + i]; // row are output synapses
        input_synapse_amount += synapse_matrix[i * length + neuron_index]; // column are input synapses
    }


    // if input neuron at least one input synapse
    if(neuron_is_input==1){
        input_synapse_amount = 1;
    }

    if(neuron_is_output==1){
        output_synapse_amount = 1; // output neurons have one output synapse for now
    }

    // alloc memory to for synapses
    neuron->input_synapses = malloc(input_synapse_amount * sizeof(synapse_t));
    neuron->output_synapses = malloc(output_synapse_amount * sizeof(synapse_t));
    neuron->input_synapse_amount = input_synapse_amount;
    neuron->output_synapse_amount = output_synapse_amount;
}


void add_input_synapsis_to_neuron(lif_neuron_t *neuron, synapse_t *synapse){
    neuron->input_synapses[neuron->actual_input_synapse] = *synapse;
    neuron->actual_input_synapse++;
}
void add_output_synapsis_to_neuron(lif_neuron_t *neuron, synapse_t *synapse){
    neuron->output_synapses[neuron->actual_output_synapse] = *synapse;
    neuron->actual_output_synapse++;
}

void initialize_synapse_data(synapse_t *synap){
    //synapse_t synap;
    int max_spikes = 50;
    synap->w = 10;
    synap->delay = 1;
    
    // initialize spike list
    synap->l_spike_times = malloc(max_spikes * sizeof(int)); // 10 spikes can be stored
    for (int l = 0; l < max_spikes; l++)
        synap->l_spike_times[l] = -1;
    
    // initialize control indexes
    synap->next_spike = 0;
    synap->last_spike = 0;
    synap->max_spikes = max_spikes;
}

// initialize synapses of a neuron (the row)
void initialize_synapses(lif_neuron_t *pre_neuron, lif_neuron_t *post_neuron, int pre_index, int post_index, int *synapse_matrix, int number_neurons, int neuron_is_input, int neuron_is_output){
    for(int i=0; i<synapse_matrix[pre_index*number_neurons + post_index]; i++){
        //synapse_t synap;
        synapse_t *synap;
        synap = malloc(sizeof(synapse_t));
        initialize_synapse_data(synap);

        printf("Adding synapse between %d and %d neurons\n", pre_index+1, post_index+1);

        add_input_synapsis_to_neuron(post_neuron, synap); // synapse is input of the post synaptic neuron
        add_output_synapsis_to_neuron(pre_neuron, synap); // synapse is the output of the pre synaptic neuron
    }
}

void add_network_input_synapse(lif_neuron_t *input_neuron){
    synapse_t *synap;
    synap = malloc(sizeof(synapse_t));
    initialize_synapse_data(synap);
    add_input_synapsis_to_neuron(input_neuron, synap);
}

void add_network_output_synapse(lif_neuron_t *output_neuron){
    synapse_t *synap;
    synap = malloc(sizeof(synapse_t));
    initialize_synapse_data(synap);
    add_output_synapsis_to_neuron(output_neuron, synap);
}

void initialize_network(spiking_nn_t *snn, int neurons, int number_input_neurons, int number_output_neurons, int *synapses){//, float *synapse_weights, float *synapse_delays) {
    lif_neuron_t *lif_neurons = malloc(neurons * sizeof(lif_neuron_t));
    
    // initialize neurons
    int input_synapse_amount = 0, output_synapse_amount = 0;
    for(int i = 0; i<neurons; i++)
    {
        int neuron_is_input = 0, neuron_is_output = 0;
        if(i<number_input_neurons) neuron_is_input = 1;

        if((neurons - i) <= number_output_neurons)
            neuron_is_output = 1;

        initialize_lif_neuron(&lif_neurons[i], synapses, neurons, neuron_is_input, neuron_is_output, i);
    }

    // initialize synapses
    for(int i = 0; i<neurons; i++){
        // initialize synapse
        int neuron_is_input = 0, neuron_is_output = 0;
        if(i<number_input_neurons) 
            neuron_is_input = 1;

        if((neurons - i) <= number_output_neurons)
            neuron_is_output = 1;

        for(int j = 0; j<neurons; j++){
            if(synapses[i*neurons + j]>0) // create synapse if it exists
                initialize_synapses(&lif_neurons[i], &lif_neurons[j], i, j, synapses, neurons, neuron_is_input, neuron_is_output);
        }

        if(neuron_is_input){
            add_network_input_synapse(&lif_neurons[i]);
        }
        if(neuron_is_output){
            add_network_output_synapse(&lif_neurons[i]);
        }
    }

    // set neurons to snn network
    snn->lif_neurons = lif_neurons;
    snn->neuron_amount = neurons;
}


void construct_motifs(int *motif_list, int n_motifs){

}

/* main.c */
int main(int argc, char *argv[]) {
    // variables definition
    int execution_type, neuron_type, motifs, n_neurons_motifs;
    int *motif_list;

    int number_input, number_output; // neurons or motifs

    int *synapse_matrix, *delays_matrix;
    float *weights_matrix;

    void *neuron_initializer;
    void *step_function;

    // execution type (0: clock; 1 event driven)
    execution_type = strtoul(argv[1], NULL, 10);

    // neuron type for the execution. All neurons are of the same type
    neuron_type = strtoul(argv[2], NULL, 10);

    // input are individual neurons or motifs
    motifs = strtoul(argv[3], NULL, 10);

    // number of neurons or motifs. In case of the motifs it is a file
    // indicating the type of each motifs. In case of neurons it is the amount of
    // neurons
    

    // input are motifs (motif types are loaded from a file)
    if(motifs==1) {
        load_motifs_file(argv[4], motif_list, &n_neurons_motifs);

        // move this to function?
        construct_motifs(motif_list, n_neurons_motifs);
    } 
    // input are individual neurons (only a number is necessary)
    else {
        n_neurons_motifs = strtoul(argv[4], NULL, 10);

        // move this to function?
        synapse_matrix = malloc(n_neurons_motifs * n_neurons_motifs * sizeof(int));
        weights_matrix = malloc(n_neurons_motifs * n_neurons_motifs * sizeof(float));
        delays_matrix = malloc(n_neurons_motifs * n_neurons_motifs * sizeof(int));
    }

    number_input = strtoul(argv[5], NULL, 10); // number of neuron used as input for the network
    number_output = strtoul(argv[6], NULL, 10); // number of neuron used as input for the network

    printf("Execution properies:\n");
    printf("- Execution type = %d\n", execution_type);
    printf("- Neuron type for exectution = %d\n", neuron_type);
    printf("Motifs = %d\n", motifs);

    switch (neuron_type)
    {
        case 0: // LIF

            break;
    
        case 1: // HH
            break;
        default:
            break;
    }

    // load synapse matrix
    FILE *f;
    load_synapse_matrix(f, argv[6], synapse_matrix, number_neurons);
    print_matrix(number_neurons, number_neurons, synapse_matrix);
    
    int time_steps = strtoul(argv[7], NULL, 10);

    // Load weight matrix and synapse matrix
    /*if (strcmp(argv[5], "0") == 0) { 
        // generate weight matrix
    }
    else {
        // load weight matrix from file
    }

    if (strcmp(argv[6], "0") == 0) { 
        // generate weight matrix    
    }
    else {
        // load delay matrix from file
    }*/


   // Network initialization
    spiking_nn_t snn;
    initialize_network(&snn, number_neurons, number_input_neurons, number_output_neurons, synapse_matrix);
    printf("Network succesfully initialized!\n");

    printf("Network properties:\n");
    int check_number_neurons = 0;
    for(int i = 0; i<snn.neuron_amount; i++){
        check_number_neurons += 1;
    }
    printf("Number of neurons: %d\n", check_number_neurons);

    for (int i = 0; i<check_number_neurons; i++)
    {
        printf("Neuron %d: input synapses = %d and output synapses = %d\n", 
                i+1, snn.lif_neurons[i].input_synapse_amount, snn.lif_neurons[i].output_synapse_amount);
    }
    
    // Check synapses
    for(int i = 0; i<number_neurons; i++){
        printf("Neuron n%d:\n", i+1);
        printf("Checking input synapses...\n");
        for(int j = 0; j<snn.lif_neurons[i].input_synapse_amount; j++){
            //snn.lif_neurons[i].input_synapses[j].l_spike_times[10] = -1;
            printf("%f ", snn.lif_neurons[i].input_synapses[j].w);
        }
        printf("Input synapses checked!\n");
        printf("Checking output synapses...\n");
        for(int j = 0; j<snn.lif_neurons[i].output_synapse_amount; j++){
            //snn.lif_neurons[i].output_synapses[j].l_spike_times[10] = -1;
            printf("%f ", snn.lif_neurons[i].output_synapses[j].w);
        }
        printf("Output synapses checked!\n");
    }

    // INTRODUCIR SPIKES
    // leer fichero con el input
    int **input_trains = malloc(number_input_neurons * sizeof(int *));
    f = fopen(argv[8], "r");

    for (int i = 0; i<number_input_neurons; i++){
        //input_trains[i] = malloc(time_steps * sizeof(int));

        // read file
        if (f == NULL){
            perror("Error opening the file\n");
            return 1;
        }
        
        load_input_spike_train(f, &(snn.lif_neurons[i].input_synapses[0])); // input neurons
        // only have one synapse
    }  


    // print input spike trains
    printf("Printing input spike trains\n");
    for(int i = 0; i<number_input_neurons; i++)
    {
        for (int j = 0; j<=snn.lif_neurons[i].input_synapses[0].last_spike; j++)
        {
            printf("%d ", snn.lif_neurons[i].input_synapses[0].l_spike_times[j]);
        }
        printf("\n");
    }
    printf("\n======================\n");

    // training 

    unsigned char **generated_spikes = malloc(number_neurons * sizeof(unsigned char *));
    for (int i = 0; i<number_neurons; i++)
        generated_spikes[i] = malloc(time_steps * sizeof(unsigned char));
    
    if(execution_type == 0){ // clock
        printf("Initializing training / simulation\n");
        int step = 0;
        while(step < time_steps){
            // procesar todas las neuronas
            #pragma omp parallel for
            for(int i=0; i<snn.neuron_amount; i++){
                forward_pass(&snn.lif_neurons[i], step, i, generated_spikes);

                if(i==0 && step % 5 == 0){
                    printf("MP: %f\n", snn.lif_neurons[i].v);
                }
            }             
            step++;
        }
    }
    /*else{

    }*/

    // print spikes generated by each neuron
    FILE *output_file;
    output_file = fopen("output_spikes.txt", "w");
    if(output_file == NULL){
        printf("Error opening the file. \n");
        exit(1);
    }
    for (int i = 0; i<number_neurons; i++)
    {
        for(int j = 0; j<time_steps; j++){
            fprintf(output_file, "%c", generated_spikes[i][j]);
        }
        fprintf(output_file, "\n");
    }
    
}